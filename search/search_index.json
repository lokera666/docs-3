{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome # Welcome to the Flare Network Technical Documentation site! These are the main sections: Concepts : In-depth descriptions of Flare's key concepts and tools. User Guides : Step-by-step guides on how to use tools like the Block Explorer or the different wallets. Infrastructure Guides : Step-by-step guides on how to deploy the different components that make up the Flare ecosystem, and be rewarded for it. Developer Docs : Programming tutorials to help you build your app using Flare's tech. Exchange Guides : Hints and advice for exchanges willing to support the Flare blockchain. Note These pages are a Work In Progress . Join the Flare community on Discord if there is anything you cannot find here.","title":"Welcome"},{"location":"#welcome","text":"Welcome to the Flare Network Technical Documentation site! These are the main sections: Concepts : In-depth descriptions of Flare's key concepts and tools. User Guides : Step-by-step guides on how to use tools like the Block Explorer or the different wallets. Infrastructure Guides : Step-by-step guides on how to deploy the different components that make up the Flare ecosystem, and be rewarded for it. Developer Docs : Programming tutorials to help you build your app using Flare's tech. Exchange Guides : Hints and advice for exchanges willing to support the Flare blockchain. Note These pages are a Work In Progress . Join the Flare community on Discord if there is anything you cannot find here.","title":"Welcome"},{"location":"dev/","text":"Developer Docs # Quick links Main code repositories: Validator node , Smart contracts Price provider: NPM Kickoff package , Reference implementation Explorers: Flare , Songbird , Coston Discord Flare and the EVM # The Songbird and Flare networks runs the Ethereum EVM, which means that Ethereum contracts and tools can be used to develop on top of these chains. Both networks are layer 1 networks, and are running independently of main-net Ethereum. All existing tools and technologies available for Ethereum can be leveraged on Songbird and Flare. The main infrastructure ( FTSO , State Connector , ...) is written in Solidity using standard tools: ethers, web3, hardhat. FAQ # How can I interact with Flare's networks? # You can interact with Flare and Songbird through: The block explorers . MetaMask and other wallets . Local development tools such as hardhat . Connection configuration for all networks is described in the Networks Configuration section . Does Flare support Ethereum-style contracts? # Ethereum style contracts are supported by both Flare and Songbird. Does Flare support NFTs? # Flare and Songbird networks support NFTs and many have already been created on Songbird. The block explorers support displaying NFTs. How do I verify if a transaction is finalized using web3? # On Flare and Songbird obtaining the receipt of a submitted transaction does not guarantee that the transaction is finalized. One has to wait until the sender's account nonce increases. Here is an example of a helper function with exponential backoff that can be used to send signed transactions and wait for finalization. async function sendAndFinalize ( senderAddress , signedTx , delay = 1000 ) { let oldNonce = await web3 . eth . getTransactionCount ( senderAddress ); let receipt = await sendSignedTransaction ( signedTx . rawTransaction ) let backoff = 1.5 ; let maxRetries = 8 ; while (( await web3 . eth . getTransactionCount ( senderAddress )) == oldNonce ) { await new Promise (( resolve ) => { setTimeout (()=>{ resolve ()}, delay )}) maxRetries -- ; if ( maxRetries == 0 ) { throw new Error ( \"Response timeout\" ); } delay = Math . floor ( delay * backoff ); } return receipt ; } How do I obtain a revert reason for a reverting contract call using web3? # In order to obtain the revert message of a reverted contract call transaction one has to follow the following steps: Catch the exception, and check if the revert reason is part of the exception data. If not: Repeat the same contract call while using .call(...) syntax and parse the revert reason. Note that second step should be performed as soon as possible, to ensure that the chain has a similar state for both calls. Is there a code example for reading the revert reason? # Below is a generic helper function to demonstrate this. Note that it relies on the function sendAndFinalize (see one of the previous answers above). async contractCall ( account , from , to , gas , gasPrice , fnToEncode , nonce ) { let tx = { from , to , gas , gasPrice , data : fnToEncode . encodeABI (), nonce }; let signedTx = await account . signTransaction ( tx ); try { return await sendSignedTransaction ( signedTx . rawTransaction ); } catch ( e ) { if ( e . message . indexOf ( \"Transaction has been reverted by the EVM\" ) < 0 ) { throw new Error ( e . message ); } else { // throws Exception with revert message await fnToEncode . call ({ from : account . address }) throw Error ( 'unlikely to happen: ' + JSON . stringify ( result )) } } } Here account and fnToEncode are obtained, for example, as follows: let account = web3 . eth . accounts . privateKeyToAccount ( privateKey ) let fnToEncode = web3Contract . methods . someMethodOnContract ( param1 , param2 ) How do I reliably read events with web3? # Subscription to events, for example using listeners in the ethers library, has proved to be unreliable, especially when high traffic exists on the network. To reliably read events it is recommended to use the getPastEvents function on web3 contracts. This function has parameters fromBlock and toBlock . User has to track for which blocks the information was obtained and for which it wasn't. The number of blocks the user can specify in one web3 RPC call depends on the configuration of the RPC node being used. In particular, if the node is run with the environment variable WEB3_API set to debug (so-called \"full node\"), usually 100 blocks of events can be read from the node through RPC call, whereas if WEB3_API=enabled (\"light node\") only 1 block of events can be read.","title":"Developer Docs"},{"location":"dev/#developer-docs","text":"Quick links Main code repositories: Validator node , Smart contracts Price provider: NPM Kickoff package , Reference implementation Explorers: Flare , Songbird , Coston Discord","title":"Developer Docs"},{"location":"dev/#flare-and-the-evm","text":"The Songbird and Flare networks runs the Ethereum EVM, which means that Ethereum contracts and tools can be used to develop on top of these chains. Both networks are layer 1 networks, and are running independently of main-net Ethereum. All existing tools and technologies available for Ethereum can be leveraged on Songbird and Flare. The main infrastructure ( FTSO , State Connector , ...) is written in Solidity using standard tools: ethers, web3, hardhat.","title":"Flare and the EVM"},{"location":"dev/#faq","text":"","title":"FAQ"},{"location":"dev/#how-can-i-interact-with-flares-networks","text":"You can interact with Flare and Songbird through: The block explorers . MetaMask and other wallets . Local development tools such as hardhat . Connection configuration for all networks is described in the Networks Configuration section .","title":"How can I interact with Flare's networks?"},{"location":"dev/#does-flare-support-ethereum-style-contracts","text":"Ethereum style contracts are supported by both Flare and Songbird.","title":"Does Flare support Ethereum-style contracts?"},{"location":"dev/#does-flare-support-nfts","text":"Flare and Songbird networks support NFTs and many have already been created on Songbird. The block explorers support displaying NFTs.","title":"Does Flare support NFTs?"},{"location":"dev/#how-do-i-verify-if-a-transaction-is-finalized-using-web3","text":"On Flare and Songbird obtaining the receipt of a submitted transaction does not guarantee that the transaction is finalized. One has to wait until the sender's account nonce increases. Here is an example of a helper function with exponential backoff that can be used to send signed transactions and wait for finalization. async function sendAndFinalize ( senderAddress , signedTx , delay = 1000 ) { let oldNonce = await web3 . eth . getTransactionCount ( senderAddress ); let receipt = await sendSignedTransaction ( signedTx . rawTransaction ) let backoff = 1.5 ; let maxRetries = 8 ; while (( await web3 . eth . getTransactionCount ( senderAddress )) == oldNonce ) { await new Promise (( resolve ) => { setTimeout (()=>{ resolve ()}, delay )}) maxRetries -- ; if ( maxRetries == 0 ) { throw new Error ( \"Response timeout\" ); } delay = Math . floor ( delay * backoff ); } return receipt ; }","title":"How do I verify if a transaction is finalized using web3?"},{"location":"dev/#how-do-i-obtain-a-revert-reason-for-a-reverting-contract-call-using-web3","text":"In order to obtain the revert message of a reverted contract call transaction one has to follow the following steps: Catch the exception, and check if the revert reason is part of the exception data. If not: Repeat the same contract call while using .call(...) syntax and parse the revert reason. Note that second step should be performed as soon as possible, to ensure that the chain has a similar state for both calls.","title":"How do I obtain a revert reason for a reverting contract call using web3?"},{"location":"dev/#is-there-a-code-example-for-reading-the-revert-reason","text":"Below is a generic helper function to demonstrate this. Note that it relies on the function sendAndFinalize (see one of the previous answers above). async contractCall ( account , from , to , gas , gasPrice , fnToEncode , nonce ) { let tx = { from , to , gas , gasPrice , data : fnToEncode . encodeABI (), nonce }; let signedTx = await account . signTransaction ( tx ); try { return await sendSignedTransaction ( signedTx . rawTransaction ); } catch ( e ) { if ( e . message . indexOf ( \"Transaction has been reverted by the EVM\" ) < 0 ) { throw new Error ( e . message ); } else { // throws Exception with revert message await fnToEncode . call ({ from : account . address }) throw Error ( 'unlikely to happen: ' + JSON . stringify ( result )) } } } Here account and fnToEncode are obtained, for example, as follows: let account = web3 . eth . accounts . privateKeyToAccount ( privateKey ) let fnToEncode = web3Contract . methods . someMethodOnContract ( param1 , param2 )","title":"Is there a code example for reading the revert reason?"},{"location":"dev/#how-do-i-reliably-read-events-with-web3","text":"Subscription to events, for example using listeners in the ethers library, has proved to be unreliable, especially when high traffic exists on the network. To reliably read events it is recommended to use the getPastEvents function on web3 contracts. This function has parameters fromBlock and toBlock . User has to track for which blocks the information was obtained and for which it wasn't. The number of blocks the user can specify in one web3 RPC call depends on the configuration of the RPC node being used. In particular, if the node is run with the environment variable WEB3_API set to debug (so-called \"full node\"), usually 100 blocks of events can be read from the node through RPC call, whereas if WEB3_API=enabled (\"light node\") only 1 block of events can be read.","title":"How do I reliably read events with web3?"},{"location":"dev/reference/api-portal/","text":"Flare API Portal # Flare's API Portal is a paid product that gives developers access to a number of private nodes running on different blockchain networks. Find the documentation for this service's API in the Flare API Portal documentation","title":"Flare API Portal"},{"location":"dev/reference/api-portal/#flare-api-portal","text":"Flare's API Portal is a paid product that gives developers access to a number of private nodes running on different blockchain networks. Find the documentation for this service's API in the Flare API Portal documentation","title":"Flare API Portal"},{"location":"dev/reference/contracts/","text":"Contract Addresses # The most secure way to retrieve contract addresses is from the blockchain itself . Alternatively, you can also get the addresses from the blockchain's source code . As a convenience, this page also provides the list of all Flare's smart contract on-chain addresses . Attention During development, it is OK to use the handy contract address list provided here. However, at least once before deploying any product , you should check that the addresses are correct using only on-chain data. Retrieval from Blockchain # The Price Submitter smart contract is deployed in the Genesis block at an immutable address: 0x1000000000000000000000000000000000000003 , both on Flare and Songbird. From it, the following contract addresses can be retrieved: The FTSO Manager ( PriceSubmitter.getFtsoManager() ) Individual FTSO contracts ( FtsoManager.getFtsos() ) The FTSO Reward Manager ( FtsoManager.rewardManager() ) WNat ( FtsoRewardManager.wNat() ) The FTSO Registry ( PriceSubmitter.getFtsoRegistry() ) The FTSO Whitelister ( PriceSubmitter.voterWhitelister() ) Note On the Flare Network, there is also a handy contract named Address Updater accessible through the Price Submitter which lists all other contracts via the getContractNamesAndAddresses() method. Address Updater ( PriceSubmitter.getAddressUpdater() ) Retrieval from Source Code # The Flare Smart Contracts repository contains an autogenerated JSON file listing the deployed addresses of all Flare contracts. You can find this file in the deployment/deploys folder, and parse it to retrieve the addresses of any Flare contract. As stated at the beginning, remember to double-check the addresses are correct using only blockchain data. Contract Flare Songbird Branch flare_network_deployed_code songbird_network_deployed_code JSON file flare.json songbird.json Retrieval from Documentation # Finally, for convenience, here is the list of all contract addresses. As stated at the beginning, remember to double-check the addresses are correct using only blockchain data. Contract Flare Address Songbird Address Address Updater 0xbAF89d... FTSO Registry 0xcD099A... 0x6D222f... FTSO Price Submitter 0x100000... 0x100000... FTSO Reward Manager 0x6D55E2... 0xc57383... FTSO Whitelister 0x0F4549... 0xa76906... WNat 0x1D80c4... 0x02f082...","title":"Contract Addresses"},{"location":"dev/reference/contracts/#contract-addresses","text":"The most secure way to retrieve contract addresses is from the blockchain itself . Alternatively, you can also get the addresses from the blockchain's source code . As a convenience, this page also provides the list of all Flare's smart contract on-chain addresses . Attention During development, it is OK to use the handy contract address list provided here. However, at least once before deploying any product , you should check that the addresses are correct using only on-chain data.","title":"Contract Addresses"},{"location":"dev/reference/contracts/#retrieval-from-blockchain","text":"The Price Submitter smart contract is deployed in the Genesis block at an immutable address: 0x1000000000000000000000000000000000000003 , both on Flare and Songbird. From it, the following contract addresses can be retrieved: The FTSO Manager ( PriceSubmitter.getFtsoManager() ) Individual FTSO contracts ( FtsoManager.getFtsos() ) The FTSO Reward Manager ( FtsoManager.rewardManager() ) WNat ( FtsoRewardManager.wNat() ) The FTSO Registry ( PriceSubmitter.getFtsoRegistry() ) The FTSO Whitelister ( PriceSubmitter.voterWhitelister() ) Note On the Flare Network, there is also a handy contract named Address Updater accessible through the Price Submitter which lists all other contracts via the getContractNamesAndAddresses() method. Address Updater ( PriceSubmitter.getAddressUpdater() )","title":"Retrieval from Blockchain"},{"location":"dev/reference/contracts/#retrieval-from-source-code","text":"The Flare Smart Contracts repository contains an autogenerated JSON file listing the deployed addresses of all Flare contracts. You can find this file in the deployment/deploys folder, and parse it to retrieve the addresses of any Flare contract. As stated at the beginning, remember to double-check the addresses are correct using only blockchain data. Contract Flare Songbird Branch flare_network_deployed_code songbird_network_deployed_code JSON file flare.json songbird.json","title":"Retrieval from Source Code"},{"location":"dev/reference/contracts/#retrieval-from-documentation","text":"Finally, for convenience, here is the list of all contract addresses. As stated at the beginning, remember to double-check the addresses are correct using only blockchain data. Contract Flare Address Songbird Address Address Updater 0xbAF89d... FTSO Registry 0xcD099A... 0x6D222f... FTSO Price Submitter 0x100000... 0x100000... FTSO Reward Manager 0x6D55E2... 0xc57383... FTSO Whitelister 0x0F4549... 0xa76906... WNat 0x1D80c4... 0x02f082...","title":"Retrieval from Documentation"},{"location":"dev/reference/network-configs/","text":"Network Configurations # This is the information required to run a node or to develop on the different Flare networks: Flare is the main network . Songbird is the canary network , used for testing features under \u201creal fire\u201d conditions, before deploying them on the main network. Coston is Songbird's public test network . Coston2 is Flare's public test network . General feature adoption flow. Configuration Values # Flare Songbird Coston Coston2 Chain ID 14 19 16 114 Asset Ticker FLR SGB CFLR C2FLR RPC endpoint BETA flare-api songbird-api coston-api coston2-api Rosetta API flare-rosetta - - - Block Explorer flare-explorer songbird-explorer coston-explorer coston2-explorer Test Faucet - - coston-faucet coston2-faucet All RPC endpoints are rate-limited to avoid spamming attacks. Beta Please note that the offered public RPC endpoints are in an experimental phase and might suffer unexpected downtime. Sample query curl -s -m 10 --request POST 'https://flare-api.flare.network/ext/C/rpc' \\ -H 'Content-Type: application/json' \\ -d '{ \"jsonrpc\":\"2.0\", \"method\":\"eth_blockNumber\", \"params\":[], \"id\":1 }' Returns the chain height, which should look something like: { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"0x103384\" } Additional Notes # Address derivation and format validation are the same as on Ethereum. The recommended BIP paths are m/44\u2019/60\u2019/x\u2019/0/0 (hardened) and m/44\u2019/60\u2019/0\u2019/0/x . JavaScript API Docs: https://web3js.readthedocs.io/en/v1.3.4/ Running a Node: https://github.com/flare-foundation/flare RPC Nodes for Connected Chains # Along with the endpoints listed above to interact with its own networks, Flare offers public RPC nodes for a series of other blockchain networks, to bootstrap development of connected services like attestation providers . Beta Please note that the offered public RPC endpoints are in an experimental phase and might suffer unexpected downtime. Bitcoin Litecoin Dogecoin XRPL Algorand RPC endpoint : https://bitcoin-api.flare.network Sample query curl -s -X POST -m 10 -H \"Content-type: application/json\" \\ -d '{\"jsonrpc\": \"1.0\", \"id\":\"hc\", \"method\": \"getblockchaininfo\", \"params\":[]}' \\ -u public:d681co1pe2l3wcj9adrm2orlk0j5r5gr3wghgxt58tvge594co0k1ciljxq9glei \\ https://bitcoin-api.flare.network | jq RPC endpoint : https://litecoin-api.flare.network Sample query curl -s -X POST -m 10 -H \"Content-type: application/json\" \\ -d '{\"jsonrpc\": \"1.0\", \"id\":\"hc\", \"method\": \"getblockchaininfo\", \"params\":[]}' \\ -u public:ntvzi4i1yne499t7vcdjqhhp92m3jvm0bb6dkpr406gkndvuns9sg6th3jd393uc \\ https://litecoin-api.flare.network | jq RPC endpoint : https://dogecoin-api.flare.network Sample query curl -s -X POST -m 10 -H \"Content-type: application/json\" \\ -d '{\"jsonrpc\": \"1.0\", \"id\":\"hc\", \"method\": \"getblockchaininfo\", \"params\":[]}' \\ -u public:6r1e5z3w9g6qruvkzkqvz8w67yqrq5js2cmyl2f1cncbp7gpp7tqixqskuub5v70 \\ https://dogecoin-api.flare.network | jq RPC endpoint : https://xrpl-api.flare.network Sample query curl -s -X POST -m 10 -H \"Content-type: application/json\" \\ -d '{\"method\": \"server_info\", \"params\":[{\"api_version\": 1}]}' \\ https://xrpl-api.flare.network | jq RPC endpoint : https://algorand-api.flare.network Sample query curl -s -m 10 \\ -H \"X-Algo-API-Token: zl748k3wddvld8cvn64utnslbf7otorkijp84se0f58pmuu0shgm27gttpcjpmuq\" \\ https://algorand-api.flare.network/v2/status | jq","title":"Network Configurations"},{"location":"dev/reference/network-configs/#network-configurations","text":"This is the information required to run a node or to develop on the different Flare networks: Flare is the main network . Songbird is the canary network , used for testing features under \u201creal fire\u201d conditions, before deploying them on the main network. Coston is Songbird's public test network . Coston2 is Flare's public test network . General feature adoption flow.","title":"Network Configurations"},{"location":"dev/reference/network-configs/#configuration-values","text":"Flare Songbird Coston Coston2 Chain ID 14 19 16 114 Asset Ticker FLR SGB CFLR C2FLR RPC endpoint BETA flare-api songbird-api coston-api coston2-api Rosetta API flare-rosetta - - - Block Explorer flare-explorer songbird-explorer coston-explorer coston2-explorer Test Faucet - - coston-faucet coston2-faucet All RPC endpoints are rate-limited to avoid spamming attacks. Beta Please note that the offered public RPC endpoints are in an experimental phase and might suffer unexpected downtime. Sample query curl -s -m 10 --request POST 'https://flare-api.flare.network/ext/C/rpc' \\ -H 'Content-Type: application/json' \\ -d '{ \"jsonrpc\":\"2.0\", \"method\":\"eth_blockNumber\", \"params\":[], \"id\":1 }' Returns the chain height, which should look something like: { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"0x103384\" }","title":"Configuration Values"},{"location":"dev/reference/network-configs/#additional-notes","text":"Address derivation and format validation are the same as on Ethereum. The recommended BIP paths are m/44\u2019/60\u2019/x\u2019/0/0 (hardened) and m/44\u2019/60\u2019/0\u2019/0/x . JavaScript API Docs: https://web3js.readthedocs.io/en/v1.3.4/ Running a Node: https://github.com/flare-foundation/flare","title":"Additional Notes"},{"location":"dev/reference/network-configs/#rpc-nodes-for-connected-chains","text":"Along with the endpoints listed above to interact with its own networks, Flare offers public RPC nodes for a series of other blockchain networks, to bootstrap development of connected services like attestation providers . Beta Please note that the offered public RPC endpoints are in an experimental phase and might suffer unexpected downtime. Bitcoin Litecoin Dogecoin XRPL Algorand RPC endpoint : https://bitcoin-api.flare.network Sample query curl -s -X POST -m 10 -H \"Content-type: application/json\" \\ -d '{\"jsonrpc\": \"1.0\", \"id\":\"hc\", \"method\": \"getblockchaininfo\", \"params\":[]}' \\ -u public:d681co1pe2l3wcj9adrm2orlk0j5r5gr3wghgxt58tvge594co0k1ciljxq9glei \\ https://bitcoin-api.flare.network | jq RPC endpoint : https://litecoin-api.flare.network Sample query curl -s -X POST -m 10 -H \"Content-type: application/json\" \\ -d '{\"jsonrpc\": \"1.0\", \"id\":\"hc\", \"method\": \"getblockchaininfo\", \"params\":[]}' \\ -u public:ntvzi4i1yne499t7vcdjqhhp92m3jvm0bb6dkpr406gkndvuns9sg6th3jd393uc \\ https://litecoin-api.flare.network | jq RPC endpoint : https://dogecoin-api.flare.network Sample query curl -s -X POST -m 10 -H \"Content-type: application/json\" \\ -d '{\"jsonrpc\": \"1.0\", \"id\":\"hc\", \"method\": \"getblockchaininfo\", \"params\":[]}' \\ -u public:6r1e5z3w9g6qruvkzkqvz8w67yqrq5js2cmyl2f1cncbp7gpp7tqixqskuub5v70 \\ https://dogecoin-api.flare.network | jq RPC endpoint : https://xrpl-api.flare.network Sample query curl -s -X POST -m 10 -H \"Content-type: application/json\" \\ -d '{\"method\": \"server_info\", \"params\":[{\"api_version\": 1}]}' \\ https://xrpl-api.flare.network | jq RPC endpoint : https://algorand-api.flare.network Sample query curl -s -m 10 \\ -H \"X-Algo-API-Token: zl748k3wddvld8cvn64utnslbf7otorkijp84se0f58pmuu0shgm27gttpcjpmuq\" \\ https://algorand-api.flare.network/v2/status | jq","title":"RPC Nodes for Connected Chains"},{"location":"exchange/","text":"Exchange Guides # This section contains information and bits of advice for Exchanges willing to support the Flare blockchain. The first thing you should know is that: Flare is used just like Ethereum! Even though the node code is different, Flare offers the same API as Ethereum so you can integrate with it in the same way. Deploy a Flare Observation node to access the network. Use the appropriate Chain ID . Use standard Ethereum libraries like web3.js if you want. Quick Information About Flare # Website address flare.xyz Brand assets Google Drive Node source code github.com/flare-foundation/flare Node installation documentation docs.flare.xyz/infra/observation/deploying Node requirements 8 CPU, 16 GB RAM, 2 TB disk space Maximum block rate 1 block/second. Token names FLARE , SONGBIRD Tickers FLR , SGB Tokens precision 18 decimal places Supported wallets docs.flare.xyz/user/wallets Technical information in the Network Configuration section . Note The $FLR and $SGB tokens are not ERC-20 tokens: they are the native currency of Flare (the Main network ) and Songbird (The Canary network ) respectively. As such, these tokens are handled the same way $ETH is handled on the Ethereum blockchain.","title":"Exchange Guides"},{"location":"exchange/#exchange-guides","text":"This section contains information and bits of advice for Exchanges willing to support the Flare blockchain. The first thing you should know is that: Flare is used just like Ethereum! Even though the node code is different, Flare offers the same API as Ethereum so you can integrate with it in the same way. Deploy a Flare Observation node to access the network. Use the appropriate Chain ID . Use standard Ethereum libraries like web3.js if you want.","title":"Exchange Guides"},{"location":"exchange/#quick-information-about-flare","text":"Website address flare.xyz Brand assets Google Drive Node source code github.com/flare-foundation/flare Node installation documentation docs.flare.xyz/infra/observation/deploying Node requirements 8 CPU, 16 GB RAM, 2 TB disk space Maximum block rate 1 block/second. Token names FLARE , SONGBIRD Tickers FLR , SGB Tokens precision 18 decimal places Supported wallets docs.flare.xyz/user/wallets Technical information in the Network Configuration section . Note The $FLR and $SGB tokens are not ERC-20 tokens: they are the native currency of Flare (the Main network ) and Songbird (The Canary network ) respectively. As such, these tokens are handled the same way $ETH is handled on the Ethereum blockchain.","title":"Quick Information About Flare"},{"location":"exchange/architecture/","text":"Architecture of an Exchange # What follows is the suggested architecture for a centralized Exchange. Even if your Exchange does not adopt this exact design, it defines the concepts that are used throughout the other pages in this section. General Structure # The suggested architecture uses a Central Exchange wallet with multiple User reception wallets controlled by the Exchange. General structure of an Exchange. Exchange's central wallet (hot) # This account contains the Exchange's funds required to perform user operations: Users' deposits are ultimately routed here, and users' withdrawals are taken from here. The private keys to this account need to be on an online machine (the Exchange server ) so this is considered a hot wallet . For security reasons, it is recommended that the hot wallet only contains enough funds to perform daily operations, whereas the bulk of the funds are kept in the cold wallet . Exchange's central wallet (cold) # The private keys to this account are kept in an offline machine so it is less vulnerable to attacks. Moreover, it is recommended that this is a multi-signature account so the approval of more than one administrator is required to move funds from it. Periodically (e.g., once a day) funds are transferred from or to the hot wallet so it can continue operating while the bulk of the funds are protected in the cold wallet. Users' reception wallets # When users sign up with the Exchange, a reception wallet is created for them in order to perform deposits. The reception wallets are usually empty: as soon as they receive funds these are transferred to the Exchange's hot wallet . The private keys to the reception wallets always remain under the Exchange's control; these wallets are offered to users as a convenience only. Users cannot perform any operation on these wallets other than deposits. User's wallet # This is the origin of deposits made to the Exchange and the receiver of withdrawals made from the Exchange. It can be a wallet in control of the user (the user holds its private key), a custodial wallet or another Exchange, for example. Exchange server # This is an online server, part of the Exchange's infrastructure, that receives withdrawal requests from users and monitors the reception wallets to detect incoming deposits. It holds the private keys to the hot wallet and to all the reception wallets so it can move funds from them in response to user's requests. Caution This server must be available 24/7 so it is a clear target for malicious actors. Balances DB # This database keeps track of every user's funds, since the actual tokens from all users are pooled together in the hot and cold wallets. The Exchange server updates this DB in response to user's deposits and withdrawals. Flare Observation Node # An observation node is a regular Flare node that does not partake in consensus but is still aware of the current state of the blockchain and allows submitting transactions. It is highly recommended that Exchanges deploy their own observation nodes to access the network, instead of relying on third-party services. Read the Deploying an Observation Node guide to learn how to do this. Detecting Deposits # The Exchange server must be continuously monitoring transfers into ALL reception wallets to detect incoming deposits. Here's a summary of the process: Depositing to an Exchange. The user deposits (transfers) funds to their assigned reception wallet . The transaction is detected by the Exchange server monitoring the wallets. The server can discover a new transaction as soon as it is submitted by subscribing to the pendingTransactions event. This allows showing the transaction as \"pending\" in the UI, but there is still a chance that it is reverted. To avoid problems, the Exchange should only act on transactions appearing on blocks old enough for the chance of them being reverted to be negligible. This can be done by subscribing to the newBlockHeaders event and examining the transactions in a previous block (for example, 5 blocks behind). The code below exemplifies this process ( See the web3.js documentation for the API details): // https://web3js.readthedocs.io const Web3 = require ( 'web3' ); // Use your own node URL // https://docs.flare.network/dev/reference/coston-testnet/ const web3 = new Web3 ( \"wss://coston-api.flare.network/ext/bc/C/ws\" ); // Use your receiving wallet address const receivingAddress = \"0x947c76694491d3fD67a73688003c4d36C8780A97\" ; web3 . eth . subscribe ( \"pendingTransactions\" ) . on ( \"data\" , async ( transactionHash ) => { // New transaction hash received. // Retrieve the actual transaction. let tx = await web3 . eth . getTransaction ( transactionHash ); // If it is directed to our address... if ( tx . to === receivingAddress ) { // Mark it as pending. console . log ( \"Transaction\" , tx . hash , \"is pending\" ); } }). on ( \"error\" , console . error ); web3 . eth . subscribe ( \"newBlockHeaders\" ) . on ( \"data\" , async ( blockHeader ) => { // New block has been produced. // Retrieve a block old enough to be considered confirmed. let block = await web3 . eth . getBlock ( blockHeader . number - 5 ); // Get all its transactions. block . transactions . forEach ( async ( transactionHash ) => { // Retrieve the actual transaction. let tx = await web3 . eth . getTransaction ( transactionHash ); // If it is directed to our address... if ( tx . to === receivingAddress ) { // Mark it as confirmed. console . log ( \"Transaction\" , tx . hash , \"is confirmed in block\" , block . number ); } }); }). on ( \"error\" , console . error ); Caution Note that all transactions from a block are retrieved simultaneously and this can easily trigger a rate limit on the node. A proper implementation should avoid this by serializing requests or managing the request rate manually . The server then checks the wallet address to find which user account it belongs to, and adds the received amount to the user's balance . The server announces a transaction to the network (through the Exchange's own observation node ) to move the received funds to the hot wallet . See a JavaScript example in the Ethereum documentation . Since you will be using your own node, you can skip the Alchemy part and directly use the web3 package as in the example above. The received funds are transferred to the hot wallet when the transaction is approved by the network. The reception wallets always remain empty. Performing Withdrawals # Users must request withdrawals directly to the Exchange server through its user interface . After checking that the user has the required balance, the funds are transferred from the Exchange's hot wallet directly to the user's wallet. Here's a summary of the process: Withdrawing from an Exchange. The user requests a withdrawal to the Exchange server . The request includes some kind of user ID, the requested amount and the destination wallet's address. The server checks that the user has the required balance to perform the withdrawal. The server announces a transaction to the network (through the Exchange's own observation node ) to move the requested funds from the hot wallet to the requested destination address. See a JavaScript example in the Ethereum documentation . Since you will be using your own node, you can skip the Alchemy part and directly use the web3 package as in the example above. Caution Please make sure you sign the transaction before submitting it, as shown in the example. Unsigned transactions are ignored by the network. The requested funds are transferred to the user's wallet when the transaction is approved by the network.","title":"Architecture of an Exchange"},{"location":"exchange/architecture/#architecture-of-an-exchange","text":"What follows is the suggested architecture for a centralized Exchange. Even if your Exchange does not adopt this exact design, it defines the concepts that are used throughout the other pages in this section.","title":"Architecture of an Exchange"},{"location":"exchange/architecture/#general-structure","text":"The suggested architecture uses a Central Exchange wallet with multiple User reception wallets controlled by the Exchange. General structure of an Exchange.","title":"General Structure"},{"location":"exchange/architecture/#exchanges-central-wallet-hot","text":"This account contains the Exchange's funds required to perform user operations: Users' deposits are ultimately routed here, and users' withdrawals are taken from here. The private keys to this account need to be on an online machine (the Exchange server ) so this is considered a hot wallet . For security reasons, it is recommended that the hot wallet only contains enough funds to perform daily operations, whereas the bulk of the funds are kept in the cold wallet .","title":"Exchange's central wallet (hot)"},{"location":"exchange/architecture/#exchanges-central-wallet-cold","text":"The private keys to this account are kept in an offline machine so it is less vulnerable to attacks. Moreover, it is recommended that this is a multi-signature account so the approval of more than one administrator is required to move funds from it. Periodically (e.g., once a day) funds are transferred from or to the hot wallet so it can continue operating while the bulk of the funds are protected in the cold wallet.","title":"Exchange's central wallet (cold)"},{"location":"exchange/architecture/#users-reception-wallets","text":"When users sign up with the Exchange, a reception wallet is created for them in order to perform deposits. The reception wallets are usually empty: as soon as they receive funds these are transferred to the Exchange's hot wallet . The private keys to the reception wallets always remain under the Exchange's control; these wallets are offered to users as a convenience only. Users cannot perform any operation on these wallets other than deposits.","title":"Users' reception wallets"},{"location":"exchange/architecture/#users-wallet","text":"This is the origin of deposits made to the Exchange and the receiver of withdrawals made from the Exchange. It can be a wallet in control of the user (the user holds its private key), a custodial wallet or another Exchange, for example.","title":"User's wallet"},{"location":"exchange/architecture/#exchange-server","text":"This is an online server, part of the Exchange's infrastructure, that receives withdrawal requests from users and monitors the reception wallets to detect incoming deposits. It holds the private keys to the hot wallet and to all the reception wallets so it can move funds from them in response to user's requests. Caution This server must be available 24/7 so it is a clear target for malicious actors.","title":"Exchange server"},{"location":"exchange/architecture/#balances-db","text":"This database keeps track of every user's funds, since the actual tokens from all users are pooled together in the hot and cold wallets. The Exchange server updates this DB in response to user's deposits and withdrawals.","title":"Balances DB"},{"location":"exchange/architecture/#flare-observation-node","text":"An observation node is a regular Flare node that does not partake in consensus but is still aware of the current state of the blockchain and allows submitting transactions. It is highly recommended that Exchanges deploy their own observation nodes to access the network, instead of relying on third-party services. Read the Deploying an Observation Node guide to learn how to do this.","title":"Flare Observation Node"},{"location":"exchange/architecture/#detecting-deposits","text":"The Exchange server must be continuously monitoring transfers into ALL reception wallets to detect incoming deposits. Here's a summary of the process: Depositing to an Exchange. The user deposits (transfers) funds to their assigned reception wallet . The transaction is detected by the Exchange server monitoring the wallets. The server can discover a new transaction as soon as it is submitted by subscribing to the pendingTransactions event. This allows showing the transaction as \"pending\" in the UI, but there is still a chance that it is reverted. To avoid problems, the Exchange should only act on transactions appearing on blocks old enough for the chance of them being reverted to be negligible. This can be done by subscribing to the newBlockHeaders event and examining the transactions in a previous block (for example, 5 blocks behind). The code below exemplifies this process ( See the web3.js documentation for the API details): // https://web3js.readthedocs.io const Web3 = require ( 'web3' ); // Use your own node URL // https://docs.flare.network/dev/reference/coston-testnet/ const web3 = new Web3 ( \"wss://coston-api.flare.network/ext/bc/C/ws\" ); // Use your receiving wallet address const receivingAddress = \"0x947c76694491d3fD67a73688003c4d36C8780A97\" ; web3 . eth . subscribe ( \"pendingTransactions\" ) . on ( \"data\" , async ( transactionHash ) => { // New transaction hash received. // Retrieve the actual transaction. let tx = await web3 . eth . getTransaction ( transactionHash ); // If it is directed to our address... if ( tx . to === receivingAddress ) { // Mark it as pending. console . log ( \"Transaction\" , tx . hash , \"is pending\" ); } }). on ( \"error\" , console . error ); web3 . eth . subscribe ( \"newBlockHeaders\" ) . on ( \"data\" , async ( blockHeader ) => { // New block has been produced. // Retrieve a block old enough to be considered confirmed. let block = await web3 . eth . getBlock ( blockHeader . number - 5 ); // Get all its transactions. block . transactions . forEach ( async ( transactionHash ) => { // Retrieve the actual transaction. let tx = await web3 . eth . getTransaction ( transactionHash ); // If it is directed to our address... if ( tx . to === receivingAddress ) { // Mark it as confirmed. console . log ( \"Transaction\" , tx . hash , \"is confirmed in block\" , block . number ); } }); }). on ( \"error\" , console . error ); Caution Note that all transactions from a block are retrieved simultaneously and this can easily trigger a rate limit on the node. A proper implementation should avoid this by serializing requests or managing the request rate manually . The server then checks the wallet address to find which user account it belongs to, and adds the received amount to the user's balance . The server announces a transaction to the network (through the Exchange's own observation node ) to move the received funds to the hot wallet . See a JavaScript example in the Ethereum documentation . Since you will be using your own node, you can skip the Alchemy part and directly use the web3 package as in the example above. The received funds are transferred to the hot wallet when the transaction is approved by the network. The reception wallets always remain empty.","title":"Detecting Deposits"},{"location":"exchange/architecture/#performing-withdrawals","text":"Users must request withdrawals directly to the Exchange server through its user interface . After checking that the user has the required balance, the funds are transferred from the Exchange's hot wallet directly to the user's wallet. Here's a summary of the process: Withdrawing from an Exchange. The user requests a withdrawal to the Exchange server . The request includes some kind of user ID, the requested amount and the destination wallet's address. The server checks that the user has the required balance to perform the withdrawal. The server announces a transaction to the network (through the Exchange's own observation node ) to move the requested funds from the hot wallet to the requested destination address. See a JavaScript example in the Ethereum documentation . Since you will be using your own node, you can skip the Alchemy part and directly use the web3 package as in the example above. Caution Please make sure you sign the transaction before submitting it, as shown in the example. Unsigned transactions are ignored by the network. The requested funds are transferred to the user's wallet when the transaction is approved by the network.","title":"Performing Withdrawals"},{"location":"exchange/delegation/","text":"Delegating on the user's behalf # Delegation is one of the multiple ways in which the Flare blockchain rewards participants of the ecosystem. In particular, delegation allows token holders to put their stake behind an FTSO data provider to increase its relative weight (See this FTSO blog post for more information). In return, each time a data provider submits useful information it shares its reward with all the token holders that delegated to it . The Delegation Guide details this process for users. However, since Exchanges keep user's tokens, only Exchanges can perform delegation. If you are an Exchange and want to offer your users the ability to earn rewards by delegation, this page summarizes the process and explains how to perform it on the user's behalf. Introduction # Flare (and Songbird) accounts can delegate any percentage they choose of their tokens to one or two FTSO data providers . This limitation means that, if your Exchange keeps all users' tokens in a single wallet (as described in the Architecture of an Exchange page), you cannot give your users the option to select the data provider they want to delegate to: The wallet containing all tokens can only delegate to one (or two) data providers . Keeping this in mind, this page explains how to delegate the users' tokens and collect the rewards. Reward Epochs As shown later, several features of the delegation mechanism are timed in Reward Epochs . On Songbird, these epochs last 7 days and start every Saturday at around 8:40AM UTC . On Flare, they last 3.5 days and start roughly every Monday at 7:00 UTC and Thursday at 19:00 UTC . Selecting a data provider # It is the Exchange that must select the FTSO data provider upon which to delegate, so the first step is to choose the one you are most confident to provide consistently good data (and therefore higher rewards). Anyone can become an FTSO data provider, but only the ones that had the most voting power during the previous reward epoch are available for delegation. The list of available data providers for the current reward epoch can be retrieved from the VoterWhitelister smart contract, method getFtsoWhitelistedPriceProviders . There exist a number of websites like flaremetrics.io or ftso-signal-providers that display this information in a far more convenient way. Note Data providers take a fee before sharing their rewards with their delegators. An Exchange can decide to run its own data provider to avoid paying this fee to an external entity, at the cost of having to develop a good price prediction algorithm . Keep in mind that FTSO data providing is already a very competitive business, and only the most successful algorithms are being rewarded. Lastly, delegations can be changed at any time, but they are only taken into account once per reward epoch (See more details in the FTSO page). Therefore, depending on the time it is submitted, a new delegation will not take effect until the beginning of the next reward epoch, or the one after that . Furthermore, rewards cannot be collected until another reward epoch has elapsed . Delegation Process # See Manual Delegation and Claiming in the FTSO page.","title":"Delegating on the user's behalf"},{"location":"exchange/delegation/#delegating-on-the-users-behalf","text":"Delegation is one of the multiple ways in which the Flare blockchain rewards participants of the ecosystem. In particular, delegation allows token holders to put their stake behind an FTSO data provider to increase its relative weight (See this FTSO blog post for more information). In return, each time a data provider submits useful information it shares its reward with all the token holders that delegated to it . The Delegation Guide details this process for users. However, since Exchanges keep user's tokens, only Exchanges can perform delegation. If you are an Exchange and want to offer your users the ability to earn rewards by delegation, this page summarizes the process and explains how to perform it on the user's behalf.","title":"Delegating on the user's behalf"},{"location":"exchange/delegation/#introduction","text":"Flare (and Songbird) accounts can delegate any percentage they choose of their tokens to one or two FTSO data providers . This limitation means that, if your Exchange keeps all users' tokens in a single wallet (as described in the Architecture of an Exchange page), you cannot give your users the option to select the data provider they want to delegate to: The wallet containing all tokens can only delegate to one (or two) data providers . Keeping this in mind, this page explains how to delegate the users' tokens and collect the rewards. Reward Epochs As shown later, several features of the delegation mechanism are timed in Reward Epochs . On Songbird, these epochs last 7 days and start every Saturday at around 8:40AM UTC . On Flare, they last 3.5 days and start roughly every Monday at 7:00 UTC and Thursday at 19:00 UTC .","title":"Introduction"},{"location":"exchange/delegation/#selecting-a-data-provider","text":"It is the Exchange that must select the FTSO data provider upon which to delegate, so the first step is to choose the one you are most confident to provide consistently good data (and therefore higher rewards). Anyone can become an FTSO data provider, but only the ones that had the most voting power during the previous reward epoch are available for delegation. The list of available data providers for the current reward epoch can be retrieved from the VoterWhitelister smart contract, method getFtsoWhitelistedPriceProviders . There exist a number of websites like flaremetrics.io or ftso-signal-providers that display this information in a far more convenient way. Note Data providers take a fee before sharing their rewards with their delegators. An Exchange can decide to run its own data provider to avoid paying this fee to an external entity, at the cost of having to develop a good price prediction algorithm . Keep in mind that FTSO data providing is already a very competitive business, and only the most successful algorithms are being rewarded. Lastly, delegations can be changed at any time, but they are only taken into account once per reward epoch (See more details in the FTSO page). Therefore, depending on the time it is submitted, a new delegation will not take effect until the beginning of the next reward epoch, or the one after that . Furthermore, rewards cannot be collected until another reward epoch has elapsed .","title":"Selecting a data provider"},{"location":"exchange/delegation/#delegation-process","text":"See Manual Delegation and Claiming in the FTSO page.","title":"Delegation Process"},{"location":"exchange/troubleshooting/","text":"Troubleshooting Guide # This page contains links to other sections answering the most common support requests received when integrating with the Flare network. Regarding Node Deployment Regarding Delegation Regarding Reward Claiming","title":"Troubleshooting Guide"},{"location":"exchange/troubleshooting/#troubleshooting-guide","text":"This page contains links to other sections answering the most common support requests received when integrating with the Flare network. Regarding Node Deployment Regarding Delegation Regarding Reward Claiming","title":"Troubleshooting Guide"},{"location":"infra/","text":"Infrastructure Guides # This section contains step-by-step guides on how to deploy the different components that make up the Flare ecosystem, and be rewarded for it.","title":"Infrastructure Guides"},{"location":"infra/#infrastructure-guides","text":"This section contains step-by-step guides on how to deploy the different components that make up the Flare ecosystem, and be rewarded for it.","title":"Infrastructure Guides"},{"location":"infra/data/deploying/","text":"Deploying a Price Provider # Background # Providing prices to the FTSO system makes you a part of a decentralized oracle system. FTSO price providers submit prices to on-chain contracts deployed on the Flare and Songbird networks. The main contracts a price provider will interact with are the Price Submitter and the FTSO contracts. All the relevant contracts for the FTSO system are available on the smart contract repo (see the Developer Docs section). These contracts are deployed and verified on the Block explorer . Prerequisites # To operate a price provider you need to be familiar with: Smart contracts and Solidity. Interacting with smart contract using a web3 library. The Hardhat runtime environment. First steps # To facilitate an easier start, one can use the kick-off NPM package referenced here . This package showcases the main contracts related to whitelisting a price provider and submitting prices. The package enables you to deploy FTSO mock contracts in a local setup, and submit prices to those contracts. Working with the package should help all setup stages for your price provider. Working with this package is mostly identical to providing prices on-chain. Below aspects would be the same as working on-chain: Smart contract APIs (called functions). Events. Timing aspects are similar but not identical. The package does not cover the actual price calculation (weighted median) and rewarding as they occur on the real network. Please visit the Developer Docs section to find a link to a reference implementation of a price provider. You can find useful ideas in this code that will help you interact with the FTSO contracts and the Flare chain. Do note you will have to do some work on top of this implementation if you would like to win rewards. Providing Random numbers # The price providing process is structured as a commit/reveal scheme to prevent users from copying other user's submitted data. The commit and reveal phases have strict time windows of a few minutes. With each reveal the price provider is also providing a random number. The random number is used as a salt in the reveal-commit scheme and later used in the reward calculation process. Price providers are encouraged to provide strong cryptographically-secure random numbers with high entropy and sufficient range. Strong random numbers are important for network security since this is the only true source of randomness on the network. Random numbers also make the commit-reveal scheme resilient to attacks. Random numbers below 2 128 are considered unsafe and are rejected on reveal. Going live # Once you feel comfortable with the local NPM package, you are ready to start submitting your prices on-chain. To run on the real network you will have to face some new challenges: Gain vote power : A price provider can only whitelist himself as a provider if they have enough vote power. Observation node : It is recommended that each price provider runs an observation node. Timing issues : You will face two challenges: Align with the on-chain time data. The on-chain timestamp might skew up to 30-40 seconds from the real world time. Figure out when to submit your price data. If you submit too late, the transaction might not get included, if submitting too early the price data might not be accurate enough. Claim rewards : Be sure to claim your reward regularly and wrap them so more vote power is gained. Notes # On the real network PriceSubmitter is deployed at a fixed address 0x1000000000000000000000000000000000000003 . FAQ # What can I do to generate strong random numbers? # Use already available random number generators that provide a cryptographically-secure (pseudo) random number. One good example would be the csprng library for nodejs applications. Keep in mind that you can submit randoms with 256 bits so try to use all the bits for entropy. Strong random numbers can also be generated by using Web3 utils: web3.utils.toBN(web3.utils.randomHex(32)) How do I calculate hash for the commit-reveal scheme? # The full and up-to-date specification for the commit-reveal scheme is available in specifications on the flare smart contract repo . The following code snippets demonstrate how hashes can be generated in Typescript and Python using publicly available Web3 libraries. Typescript Python import BN from \"bn.js\" ; import { BigNumber } from \"ethers\" ; import { ethers } from \"hardhat\" ; const MIN_RANDOM = web3 . utils . toBN ( 2 ). pow ( web3 . utils . toBN ( 128 )); function submitHash ( ftsoIndices : ( number | BN | BigNumber )[], prices : ( number | BN | BigNumber )[], random : number | BN | BigNumber , address : string ) : string { return ethers . utils . keccak256 ( web3 . eth . abi . encodeParameters ( [ \"uint256[]\" , \"uint256[]\" , \"uint256\" , \"address\" ], [ ftsoIndices , prices , random , address ])); } const ftsoIndices = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]; const randoms = [ MIN_RANDOM , MIN_RANDOM . addn ( 5 ), MIN_RANDOM . addn ( 1059 ), MIN_RANDOM . addn ( 10682 ), MIN_RANDOM . addn ( 159726 ) ]; const prices = [ 0 , 1 , 2 , 3 , 5 , 10 , 50 , 100 , 101 , 10 ** 5 + 1 , 10 ** 8 ]; const addrs = [ accounts [ 10 ], accounts [ 11 ], accounts [ 12 ], accounts [ 13 ]]; console . log ( `Prices: ${ prices } ` ); for ( let addr of addrs ) { console . log ( `Address: ${ addr } ` ); for ( let random of randoms ) { console . log ( `\\tRandom: ${ random } ` ) const hash = submitHash ( ftsoIndices , prices , random , addr ); console . log ( `\\t\\t ${ hash } ` ); } } from typing import List from web3 import Web3 import eth_abi minimal_random = 2 ** 128 def submit_price_hash ( ftsoIndices : List [ int ], prices : List [ int ], random : int , address : str ) -> str : assert len ( ftsoIndices ) == len ( prices ) assert list ( sorted ( ftsoIndices )) == ftsoIndices and len ( set ( ftsoIndices ) ) == len ( ftsoIndices ), \"Indices are non increasing\" return Web3 . keccak ( eth_abi . encode_abi ( [ \"uint256[]\" , \"uint256[]\" , \"uint256\" , \"address\" ], [ ftsoIndices , prices , random , address ], ) ) . hex () def test_fun ( prices : List [ int ], random : int , address = \"0xD7de703D9BBC4602242D0f3149E5fFCD30Eb3ADF\" , ) -> List [ str ]: return submit_price_hash ( list ( range ( len ( prices ))), prices , random , address ) addrs = [ \"0xD7de703D9BBC4602242D0f3149E5fFCD30Eb3ADF\" , \"0xEa960515F8b4C237730F028cBAcF0a28E7F45dE0\" , \"0x3d91185a02774C70287F6c74Dd26d13DFB58ff16\" , ] prices = [ 0 , 1 , 2 , 3 , 5 , 10 , 50 , 100 , 101 , 10 ** 5 + 1 , 10 ** 8 ] randoms = [ min_random + r for r in [ 0 , 1 , 100 , 101 , 100000000000000000000 ] ] for addr in addrs : print ( f \"Address: { addr } \" ) for rand in randoms : print ( f \" Random: { rand } \" ) print ( \" hash:\" , test_fun ( prices , rand , addr )) print () Where can I find the contracts I need to interact with as a price provider? # The PriceSubmitter contract is deployed at the fixed address 0x1000000000000000000000000000000000000003 . All the other contracts are available as read methods on the PriceSubmitter contract. You should periodically check for updates to have up to date information. Any important updates and contract changes will be broadcasted to the community. Where can I browse the source code and documentation for contracts? # All the important contracts are verified on the Blocks Explorer . The main smart contract repo is referenced in the Developer Docs section. What are the important contracts I need to be aware of to be a price provider? # The most important is the PriceSubmitter where you submit prices. It also has links to the below contracts. FtsoRegistry : Holds information about specific FTSOs, their symbols, indices and addresses. FTSOManager : Holds epoch and voting related configuration data and oversees all FTSOs, also gives access to additional useful contracts such as Inflation and Supply contracts. VoterWhitelister : The contract where a price provider list themselves to submit prices. How much does it cost to submit prices as price provider? # Price submissions and reveals are currently discounted on Songbird and it costs approximately 3-4 SGB per day if all the submission and reveal transactions are successful. Where can I see for which FTSOs I am eligible to submit prices? # Each address is whitelisted separately for each FTSO contract. There are two ways to query whitelisting data, one through the VoterWhitelister contract, the other through the PriceSubmitter contract. How to read whitelisted addresses using the VoterWhitelister contract? # Per FTSO there is an array of whitelisted addresses. Open an FTSO contract and use the method getFtsoWhitelistedPriceProviders . Set the required index and check if your address is in this list. How to read whitelisted addresses using the PriceSubmitter contract? # Open the contract and use the method voterWhitelistBitmap where you should set the address your would like to query. The function returns a bitmap corresponding to allowed FTSO indices in big-endian format. If you were allowed to submit princess for FTSOs with indices 0, 1 and 3, the returned bitmap would be 11 ( 1011 in binary). Which currencies are available on the network? # The best way to get available currencies is to query the FtsoRegistry that holds information about available FTSOs, their addresses, prices and indices. Songbird currently supports the following symbols: XRP, LTC, XLM, DOGE, ADA, ALGO, BCH, DGB, BTC, ETH, FIL, SGB , but new ones could be added by governance vote. The Flare network will start with the same symbols as Songbird. Is there a slashing mechanism for non-availability? # There is currently no slashing for not providing a price. If you do not provide a price in a specific price epoch, your can not gain reward in that epoch. So the unavailability has a direct negative impact on your reward rate as a price provider. The network time is not the same as local time, is there something wrong? # Due to the decentralized state of the network, one might experience some occasional time drifts (+-30s). We suggest you keep synchronized local time with global time through Network Time Protocol (NTP) to avoid missing any submit/reveal periods. Where can I get information on which prices are rewarded? # Each FTSO emits a PriceFinalized event that contains information about calculated median price and rewarding bounds. How can I see who has delegated to me? # There is currently no on-chain structure that holds this data. You might want to listen to events emitted by delegations. The NPM library is written in Typescript, can I use another language to write a price provider? # You are free to use any language to run the price provider, although some might be more suitable than others. Try using a language that offers good support for Ethereum smart contracts, e.g. web3-your-language . Many successful price providers use different technologies such as: go, C#, or python. Is there any code for writing a price provider in Python? # This gist showcases the calculation of submit hashes in Python using the web3py library. Are delegations transferable between different addresses? # Delegations are currently not transferable. Specifically, you can't re-delegate the vote power that was delegated to your address. Does the price epoch vary with each FTSO? # No, price epoch configurations are governed by FtsoManager (you can get them using the getPriceEpochConfiguration method). This is necessary so that all submissions (and reveals) can happen at the same time. Can price epoch duration change? # Price epoch durations are generally fixed and will not change abruptly. Any such change will be broadcasted to the community and be part of a governance decision. Why am I getting strange reverts on submission? # One reason could be related to the status of your node. Make sure the node is healthy and has enough peers. See Troubleshooting","title":"Deploying a Price Provider"},{"location":"infra/data/deploying/#deploying-a-price-provider","text":"","title":"Deploying a Price Provider"},{"location":"infra/data/deploying/#background","text":"Providing prices to the FTSO system makes you a part of a decentralized oracle system. FTSO price providers submit prices to on-chain contracts deployed on the Flare and Songbird networks. The main contracts a price provider will interact with are the Price Submitter and the FTSO contracts. All the relevant contracts for the FTSO system are available on the smart contract repo (see the Developer Docs section). These contracts are deployed and verified on the Block explorer .","title":"Background"},{"location":"infra/data/deploying/#prerequisites","text":"To operate a price provider you need to be familiar with: Smart contracts and Solidity. Interacting with smart contract using a web3 library. The Hardhat runtime environment.","title":"Prerequisites"},{"location":"infra/data/deploying/#first-steps","text":"To facilitate an easier start, one can use the kick-off NPM package referenced here . This package showcases the main contracts related to whitelisting a price provider and submitting prices. The package enables you to deploy FTSO mock contracts in a local setup, and submit prices to those contracts. Working with the package should help all setup stages for your price provider. Working with this package is mostly identical to providing prices on-chain. Below aspects would be the same as working on-chain: Smart contract APIs (called functions). Events. Timing aspects are similar but not identical. The package does not cover the actual price calculation (weighted median) and rewarding as they occur on the real network. Please visit the Developer Docs section to find a link to a reference implementation of a price provider. You can find useful ideas in this code that will help you interact with the FTSO contracts and the Flare chain. Do note you will have to do some work on top of this implementation if you would like to win rewards.","title":"First steps"},{"location":"infra/data/deploying/#providing-random-numbers","text":"The price providing process is structured as a commit/reveal scheme to prevent users from copying other user's submitted data. The commit and reveal phases have strict time windows of a few minutes. With each reveal the price provider is also providing a random number. The random number is used as a salt in the reveal-commit scheme and later used in the reward calculation process. Price providers are encouraged to provide strong cryptographically-secure random numbers with high entropy and sufficient range. Strong random numbers are important for network security since this is the only true source of randomness on the network. Random numbers also make the commit-reveal scheme resilient to attacks. Random numbers below 2 128 are considered unsafe and are rejected on reveal.","title":"Providing Random numbers"},{"location":"infra/data/deploying/#going-live","text":"Once you feel comfortable with the local NPM package, you are ready to start submitting your prices on-chain. To run on the real network you will have to face some new challenges: Gain vote power : A price provider can only whitelist himself as a provider if they have enough vote power. Observation node : It is recommended that each price provider runs an observation node. Timing issues : You will face two challenges: Align with the on-chain time data. The on-chain timestamp might skew up to 30-40 seconds from the real world time. Figure out when to submit your price data. If you submit too late, the transaction might not get included, if submitting too early the price data might not be accurate enough. Claim rewards : Be sure to claim your reward regularly and wrap them so more vote power is gained.","title":"Going live"},{"location":"infra/data/deploying/#notes","text":"On the real network PriceSubmitter is deployed at a fixed address 0x1000000000000000000000000000000000000003 .","title":"Notes"},{"location":"infra/data/deploying/#faq","text":"","title":"FAQ"},{"location":"infra/data/deploying/#what-can-i-do-to-generate-strong-random-numbers","text":"Use already available random number generators that provide a cryptographically-secure (pseudo) random number. One good example would be the csprng library for nodejs applications. Keep in mind that you can submit randoms with 256 bits so try to use all the bits for entropy. Strong random numbers can also be generated by using Web3 utils: web3.utils.toBN(web3.utils.randomHex(32))","title":"What can I do to generate strong random numbers?"},{"location":"infra/data/deploying/#how-do-i-calculate-hash-for-the-commit-reveal-scheme","text":"The full and up-to-date specification for the commit-reveal scheme is available in specifications on the flare smart contract repo . The following code snippets demonstrate how hashes can be generated in Typescript and Python using publicly available Web3 libraries. Typescript Python import BN from \"bn.js\" ; import { BigNumber } from \"ethers\" ; import { ethers } from \"hardhat\" ; const MIN_RANDOM = web3 . utils . toBN ( 2 ). pow ( web3 . utils . toBN ( 128 )); function submitHash ( ftsoIndices : ( number | BN | BigNumber )[], prices : ( number | BN | BigNumber )[], random : number | BN | BigNumber , address : string ) : string { return ethers . utils . keccak256 ( web3 . eth . abi . encodeParameters ( [ \"uint256[]\" , \"uint256[]\" , \"uint256\" , \"address\" ], [ ftsoIndices , prices , random , address ])); } const ftsoIndices = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]; const randoms = [ MIN_RANDOM , MIN_RANDOM . addn ( 5 ), MIN_RANDOM . addn ( 1059 ), MIN_RANDOM . addn ( 10682 ), MIN_RANDOM . addn ( 159726 ) ]; const prices = [ 0 , 1 , 2 , 3 , 5 , 10 , 50 , 100 , 101 , 10 ** 5 + 1 , 10 ** 8 ]; const addrs = [ accounts [ 10 ], accounts [ 11 ], accounts [ 12 ], accounts [ 13 ]]; console . log ( `Prices: ${ prices } ` ); for ( let addr of addrs ) { console . log ( `Address: ${ addr } ` ); for ( let random of randoms ) { console . log ( `\\tRandom: ${ random } ` ) const hash = submitHash ( ftsoIndices , prices , random , addr ); console . log ( `\\t\\t ${ hash } ` ); } } from typing import List from web3 import Web3 import eth_abi minimal_random = 2 ** 128 def submit_price_hash ( ftsoIndices : List [ int ], prices : List [ int ], random : int , address : str ) -> str : assert len ( ftsoIndices ) == len ( prices ) assert list ( sorted ( ftsoIndices )) == ftsoIndices and len ( set ( ftsoIndices ) ) == len ( ftsoIndices ), \"Indices are non increasing\" return Web3 . keccak ( eth_abi . encode_abi ( [ \"uint256[]\" , \"uint256[]\" , \"uint256\" , \"address\" ], [ ftsoIndices , prices , random , address ], ) ) . hex () def test_fun ( prices : List [ int ], random : int , address = \"0xD7de703D9BBC4602242D0f3149E5fFCD30Eb3ADF\" , ) -> List [ str ]: return submit_price_hash ( list ( range ( len ( prices ))), prices , random , address ) addrs = [ \"0xD7de703D9BBC4602242D0f3149E5fFCD30Eb3ADF\" , \"0xEa960515F8b4C237730F028cBAcF0a28E7F45dE0\" , \"0x3d91185a02774C70287F6c74Dd26d13DFB58ff16\" , ] prices = [ 0 , 1 , 2 , 3 , 5 , 10 , 50 , 100 , 101 , 10 ** 5 + 1 , 10 ** 8 ] randoms = [ min_random + r for r in [ 0 , 1 , 100 , 101 , 100000000000000000000 ] ] for addr in addrs : print ( f \"Address: { addr } \" ) for rand in randoms : print ( f \" Random: { rand } \" ) print ( \" hash:\" , test_fun ( prices , rand , addr )) print ()","title":"How do I calculate hash for the commit-reveal scheme?"},{"location":"infra/data/deploying/#where-can-i-find-the-contracts-i-need-to-interact-with-as-a-price-provider","text":"The PriceSubmitter contract is deployed at the fixed address 0x1000000000000000000000000000000000000003 . All the other contracts are available as read methods on the PriceSubmitter contract. You should periodically check for updates to have up to date information. Any important updates and contract changes will be broadcasted to the community.","title":"Where can I find the contracts I need to interact with as a price provider?"},{"location":"infra/data/deploying/#where-can-i-browse-the-source-code-and-documentation-for-contracts","text":"All the important contracts are verified on the Blocks Explorer . The main smart contract repo is referenced in the Developer Docs section.","title":"Where can I browse the source code and documentation for contracts?"},{"location":"infra/data/deploying/#what-are-the-important-contracts-i-need-to-be-aware-of-to-be-a-price-provider","text":"The most important is the PriceSubmitter where you submit prices. It also has links to the below contracts. FtsoRegistry : Holds information about specific FTSOs, their symbols, indices and addresses. FTSOManager : Holds epoch and voting related configuration data and oversees all FTSOs, also gives access to additional useful contracts such as Inflation and Supply contracts. VoterWhitelister : The contract where a price provider list themselves to submit prices.","title":"What are the important contracts I need to be aware of to be a price provider?"},{"location":"infra/data/deploying/#how-much-does-it-cost-to-submit-prices-as-price-provider","text":"Price submissions and reveals are currently discounted on Songbird and it costs approximately 3-4 SGB per day if all the submission and reveal transactions are successful.","title":"How much does it cost to submit prices as price provider?"},{"location":"infra/data/deploying/#where-can-i-see-for-which-ftsos-i-am-eligible-to-submit-prices","text":"Each address is whitelisted separately for each FTSO contract. There are two ways to query whitelisting data, one through the VoterWhitelister contract, the other through the PriceSubmitter contract.","title":"Where can I see for which FTSOs I am eligible to submit prices?"},{"location":"infra/data/deploying/#how-to-read-whitelisted-addresses-using-the-voterwhitelister-contract","text":"Per FTSO there is an array of whitelisted addresses. Open an FTSO contract and use the method getFtsoWhitelistedPriceProviders . Set the required index and check if your address is in this list.","title":"How to read whitelisted addresses using the VoterWhitelister contract?"},{"location":"infra/data/deploying/#how-to-read-whitelisted-addresses-using-the-pricesubmitter-contract","text":"Open the contract and use the method voterWhitelistBitmap where you should set the address your would like to query. The function returns a bitmap corresponding to allowed FTSO indices in big-endian format. If you were allowed to submit princess for FTSOs with indices 0, 1 and 3, the returned bitmap would be 11 ( 1011 in binary).","title":"How to read whitelisted addresses using the PriceSubmitter contract?"},{"location":"infra/data/deploying/#which-currencies-are-available-on-the-network","text":"The best way to get available currencies is to query the FtsoRegistry that holds information about available FTSOs, their addresses, prices and indices. Songbird currently supports the following symbols: XRP, LTC, XLM, DOGE, ADA, ALGO, BCH, DGB, BTC, ETH, FIL, SGB , but new ones could be added by governance vote. The Flare network will start with the same symbols as Songbird.","title":"Which currencies are available on the network?"},{"location":"infra/data/deploying/#is-there-a-slashing-mechanism-for-non-availability","text":"There is currently no slashing for not providing a price. If you do not provide a price in a specific price epoch, your can not gain reward in that epoch. So the unavailability has a direct negative impact on your reward rate as a price provider.","title":"Is there a slashing mechanism for non-availability?"},{"location":"infra/data/deploying/#the-network-time-is-not-the-same-as-local-time-is-there-something-wrong","text":"Due to the decentralized state of the network, one might experience some occasional time drifts (+-30s). We suggest you keep synchronized local time with global time through Network Time Protocol (NTP) to avoid missing any submit/reveal periods.","title":"The network time is not the same as local time, is there something wrong?"},{"location":"infra/data/deploying/#where-can-i-get-information-on-which-prices-are-rewarded","text":"Each FTSO emits a PriceFinalized event that contains information about calculated median price and rewarding bounds.","title":"Where can I get information on which prices are rewarded?"},{"location":"infra/data/deploying/#how-can-i-see-who-has-delegated-to-me","text":"There is currently no on-chain structure that holds this data. You might want to listen to events emitted by delegations.","title":"How can I see who has delegated to me?"},{"location":"infra/data/deploying/#the-npm-library-is-written-in-typescript-can-i-use-another-language-to-write-a-price-provider","text":"You are free to use any language to run the price provider, although some might be more suitable than others. Try using a language that offers good support for Ethereum smart contracts, e.g. web3-your-language . Many successful price providers use different technologies such as: go, C#, or python.","title":"The NPM library is written in Typescript, can I use another language to write a price provider?"},{"location":"infra/data/deploying/#is-there-any-code-for-writing-a-price-provider-in-python","text":"This gist showcases the calculation of submit hashes in Python using the web3py library.","title":"Is there any code for writing a price provider in Python?"},{"location":"infra/data/deploying/#are-delegations-transferable-between-different-addresses","text":"Delegations are currently not transferable. Specifically, you can't re-delegate the vote power that was delegated to your address.","title":"Are delegations transferable between different addresses?"},{"location":"infra/data/deploying/#does-the-price-epoch-vary-with-each-ftso","text":"No, price epoch configurations are governed by FtsoManager (you can get them using the getPriceEpochConfiguration method). This is necessary so that all submissions (and reveals) can happen at the same time.","title":"Does the price epoch vary with each FTSO?"},{"location":"infra/data/deploying/#can-price-epoch-duration-change","text":"Price epoch durations are generally fixed and will not change abruptly. Any such change will be broadcasted to the community and be part of a governance decision.","title":"Can price epoch duration change?"},{"location":"infra/data/deploying/#why-am-i-getting-strange-reverts-on-submission","text":"One reason could be related to the status of your node. Make sure the node is healthy and has enough peers. See Troubleshooting","title":"Why am I getting strange reverts on submission?"},{"location":"infra/data/troubleshooting/","text":"Troubleshooting Price Providers # When trying to whitelist my address I get the error \"vote power too low\" # To whitelist the address of your data provider you need a minimum amount of vote power, derived both from the address' own staked $WFLR or $WSGB , and delegation . This error is caused mainly by two reasons: Your vote power is below the vote power of the 100 th provider in the current whitelist. Only the first 100 data providers can be whitelisted, strictly ordered by voting power, so you need to increase yours. Your vote power is high enough, but it hasn't been taken into account yet. Keep in mind that vote power is only read and whitelists updated once per reward epoch. On Songbird reward epochs start roughly on Saturdays at 8:40AM UTC, so you might need to wait. I have increased my vote power, but the address is still not getting whitelisted, what is wrong? # Addresses are whitelisted based on vote power as reflected in the vote power block of the current reward epoch. Increased vote power on a different block will not enable your address to be whitelisted. How do I find the vote power block of the current reward epoch? # In the FtsoManager contract use method getCurrentRewardEpoch . Then use getRewardEpochVotePowerBlock where one should set the current reward epoch number and see the vote power block for that epoch. How do I check my vote power for a specific vote power block? # In the WNat contract use votePowerOfAt, set the address and the block and read the response. My submissions are reverted as being in the wrong epoch # You might be submitting a bit too late in the current epoch. Try to submit the price a few seconds earlier. You might want to consider running an observation node that provides a better quality connection to the network. Also, check if your server time is synced through Network Time Protocol (NTP). I am experiencing strange reverts when submitting and revealing prices # The unexpected reverts might come from the too low gas amount provided to submit/reveal transactions. Increase the gas limit of the transaction to 2'500'000 gwei.","title":"Troubleshooting Price Providers"},{"location":"infra/data/troubleshooting/#troubleshooting-price-providers","text":"","title":"Troubleshooting Price Providers"},{"location":"infra/data/troubleshooting/#when-trying-to-whitelist-my-address-i-get-the-error-vote-power-too-low","text":"To whitelist the address of your data provider you need a minimum amount of vote power, derived both from the address' own staked $WFLR or $WSGB , and delegation . This error is caused mainly by two reasons: Your vote power is below the vote power of the 100 th provider in the current whitelist. Only the first 100 data providers can be whitelisted, strictly ordered by voting power, so you need to increase yours. Your vote power is high enough, but it hasn't been taken into account yet. Keep in mind that vote power is only read and whitelists updated once per reward epoch. On Songbird reward epochs start roughly on Saturdays at 8:40AM UTC, so you might need to wait.","title":"When trying to whitelist my address I get the error \"vote power too low\""},{"location":"infra/data/troubleshooting/#i-have-increased-my-vote-power-but-the-address-is-still-not-getting-whitelisted-what-is-wrong","text":"Addresses are whitelisted based on vote power as reflected in the vote power block of the current reward epoch. Increased vote power on a different block will not enable your address to be whitelisted.","title":"I have increased my vote power, but the address is still not getting whitelisted, what is wrong?"},{"location":"infra/data/troubleshooting/#how-do-i-find-the-vote-power-block-of-the-current-reward-epoch","text":"In the FtsoManager contract use method getCurrentRewardEpoch . Then use getRewardEpochVotePowerBlock where one should set the current reward epoch number and see the vote power block for that epoch.","title":"How do I find the vote power block of the current reward epoch?"},{"location":"infra/data/troubleshooting/#how-do-i-check-my-vote-power-for-a-specific-vote-power-block","text":"In the WNat contract use votePowerOfAt, set the address and the block and read the response.","title":"How do I check my vote power for a specific vote power block?"},{"location":"infra/data/troubleshooting/#my-submissions-are-reverted-as-being-in-the-wrong-epoch","text":"You might be submitting a bit too late in the current epoch. Try to submit the price a few seconds earlier. You might want to consider running an observation node that provides a better quality connection to the network. Also, check if your server time is synced through Network Time Protocol (NTP).","title":"My submissions are reverted as being in the wrong epoch"},{"location":"infra/data/troubleshooting/#i-am-experiencing-strange-reverts-when-submitting-and-revealing-prices","text":"The unexpected reverts might come from the too low gas amount provided to submit/reveal transactions. Increase the gas limit of the transaction to 2'500'000 gwei.","title":"I am experiencing strange reverts when submitting and revealing prices"},{"location":"infra/data/whitelisting/","text":"Whitelisting a Price Provider # Procedure # Only top vote power holders per FTSO are allowed to submit prices. Per FTSO, the vote power of an address is based on the wrapped tokens balance ( $WFLR or $WSGB ). Whitelisting a price provider is done in a fully decentralized way and facilitated by the VoterWhitelister contract. Price providers can request to be whitelisted for a specific asset index using requestWhitelistingVoter() or request whitelisting for all assets at once requestFullVoterWhitelisting() . The VoterWhitelister contract enables price submissions only by whitelisted addresses. For each FTSO, up to N (currently 100) voters can be listed. The number of voters per asset can vary and is configurable by Governance. When a price provider tries to whitelist itself, its vote power is calculated using the vote power block of the current reward epoch. The prerequisite for a price provider is explicit whitelisting. Each user can request its address to be whitelisted by the VoterWhitelister contract. If the whitelist is not full, the address is immediately whitelisted. If the list is full, the user with the lowest voter power is found and replaced with the requesting user only if the new user's power is strictly greater. Should the number of voter slots ever be reduced, voter addresses will be removed from the whitelist one by one, each time removing the address with the lowest power. Events are fired to notify voters about the change of voter status on the whitelist. There are two methods that you can use to whitelist your public address. The method requestFullVoterWhitelisting tries to whitelist your address for all available FTSOs, while requestWhitelistingVoter tries to whitelist the address for a specified FTSO index. FAQ # Is there a minimal vote power required to be whitelisted as a price provider? # There is no minimum vote power required. Top 100 price providers with the highest vote power can provide prices. This is handled on-chain by the VoterWhitelister contract. Once all the slots in the list are taken and a new address is being whitelisted, the address with the lowest vote power will be kicked out of the list. Where can I check if I am whitelisted as a price provider? # Every time a new price provider\u2019s address is added to the whitelist (or an old one is removed), an event is emitted. Once an address is unlisted, submissions will also start failing (reverting). It can also help to listen to events that will notify you about delisting once it happens. If I was removed from the whitelist, how can I re-list myself? # If your address was kicked out of the whitelist, you will be able to list yourself once the next reward epoch starts. For doing this you will need more vote power than one of the listed providers. You should see if you can have more delegations done to your address before the next reward epoch vote power block (snapshot) is chosen. You should probably try to re-list anyway, since maybe some other provider has fewer delegations and lower vote power than you by the time you try again. See also troubleshooting","title":"Whitelisting a Price Provider"},{"location":"infra/data/whitelisting/#whitelisting-a-price-provider","text":"","title":"Whitelisting a Price Provider"},{"location":"infra/data/whitelisting/#procedure","text":"Only top vote power holders per FTSO are allowed to submit prices. Per FTSO, the vote power of an address is based on the wrapped tokens balance ( $WFLR or $WSGB ). Whitelisting a price provider is done in a fully decentralized way and facilitated by the VoterWhitelister contract. Price providers can request to be whitelisted for a specific asset index using requestWhitelistingVoter() or request whitelisting for all assets at once requestFullVoterWhitelisting() . The VoterWhitelister contract enables price submissions only by whitelisted addresses. For each FTSO, up to N (currently 100) voters can be listed. The number of voters per asset can vary and is configurable by Governance. When a price provider tries to whitelist itself, its vote power is calculated using the vote power block of the current reward epoch. The prerequisite for a price provider is explicit whitelisting. Each user can request its address to be whitelisted by the VoterWhitelister contract. If the whitelist is not full, the address is immediately whitelisted. If the list is full, the user with the lowest voter power is found and replaced with the requesting user only if the new user's power is strictly greater. Should the number of voter slots ever be reduced, voter addresses will be removed from the whitelist one by one, each time removing the address with the lowest power. Events are fired to notify voters about the change of voter status on the whitelist. There are two methods that you can use to whitelist your public address. The method requestFullVoterWhitelisting tries to whitelist your address for all available FTSOs, while requestWhitelistingVoter tries to whitelist the address for a specified FTSO index.","title":"Procedure"},{"location":"infra/data/whitelisting/#faq","text":"","title":"FAQ"},{"location":"infra/data/whitelisting/#is-there-a-minimal-vote-power-required-to-be-whitelisted-as-a-price-provider","text":"There is no minimum vote power required. Top 100 price providers with the highest vote power can provide prices. This is handled on-chain by the VoterWhitelister contract. Once all the slots in the list are taken and a new address is being whitelisted, the address with the lowest vote power will be kicked out of the list.","title":"Is there a minimal vote power required to be whitelisted as a price provider?"},{"location":"infra/data/whitelisting/#where-can-i-check-if-i-am-whitelisted-as-a-price-provider","text":"Every time a new price provider\u2019s address is added to the whitelist (or an old one is removed), an event is emitted. Once an address is unlisted, submissions will also start failing (reverting). It can also help to listen to events that will notify you about delisting once it happens.","title":"Where can I check if I am whitelisted as a price provider?"},{"location":"infra/data/whitelisting/#if-i-was-removed-from-the-whitelist-how-can-i-re-list-myself","text":"If your address was kicked out of the whitelist, you will be able to list yourself once the next reward epoch starts. For doing this you will need more vote power than one of the listed providers. You should see if you can have more delegations done to your address before the next reward epoch vote power block (snapshot) is chosen. You should probably try to re-list anyway, since maybe some other provider has fewer delegations and lower vote power than you by the time you try again. See also troubleshooting","title":"If I was removed from the whitelist, how can I re-list myself?"},{"location":"infra/observation/deploying/","text":"Deploying an Observation Node # Introduction # Observation nodes enable anyone to observe the network and submit transactions. Unlike validator nodes , which provide state consensus and add blocks, observation nodes remain outside the network and have no effect on consensus or blocks. Running an observation node is optional. However, submitting transactions through your own node offers a number of benefits: Transactions are sent directly to the network instead of through a third party, removing a potential security risk. Public nodes are usually rate-limited (the amount of requests they accept per second is restricted). Your own node does not have such restriction. The time savings described above allow FTSO data providers to submit their data a few seconds later, thus having more time to gather price data before submitting. This guide explains how to deploy your own observation node so you can reap these benefits. Prerequisites # This guide contains different instructions depending on which Flare Network you want to deploy to, so make sure you are aware of the available networks . Flare Songbird Coston Coston 2 Hardware Software CPU cores 8 Operating System Ubuntu (18.04 or 20.04) or macOS (>= 10.15 Catalina) RAM 32 Dependencies Go (>= 1.18.5) Disk space 1 TB SSD gcc Disk growth 2.5 TB/year g++ jq Hardware Software CPU cores 8 Operating System Ubuntu (18.04 or 20.04) or macOS (>= 10.15 Catalina) RAM 32 Dependencies Go (>= 1.16.8) Disk space 3.5 TB SSD gcc Disk growth 2.5 TB/year g++ jq Hardware Software CPU cores 4 Operating System Ubuntu (18.04 or 20.04) or macOS (>= 10.15 Catalina) RAM 16 Dependencies Go (>= 1.16.8) Disk space 500 GB SSD gcc Disk growth 250 GB/year g++ jq Hardware Software CPU cores 4 Operating System Ubuntu (18.04 or 20.04) or macOS (>= 10.15 Catalina) RAM 16 Dependencies Go (>= 1.18.5) Disk space 500 GB SSD gcc Disk growth 250 GB/year g++ jq Plus a reliable IPv4 or IPv6 network connection, with an open public port. Keep in mind that enabling pruning as described below can reduce the required disk space by as much as 60%. Guide # 1. Installation # Flare & Coston 2 Songbird & Coston Clone the go-flare repository and run the build.sh script: git clone https://github.com/flare-foundation/go-flare.git cd go-flare/avalanchego ./scripts/build.sh The resulting executable will be build/avalanchego . Note You can verify the installation by running: go test $( go list ./... | grep -v /tests/ ) # avalanchego unit tests cd ../coreth go test ./... # coreth unit tests cd ../avalanchego Clone the go-songbird repository and run the build.sh script: git clone https://github.com/flare-foundation/go-songbird.git cd go-songbird ./scripts/build.sh The resulting executable will be build/flare . Note You can verify the installation by running: go test $( go list ./... | grep -v /tests/ ) # avalanchego unit tests cd coreth go test ./... # coreth unit tests cd .. 2. Node Whitelisting # While the Flare and Songbird networks are being tested, all nodes wanting to peer with them (including observation nodes) need to have their IP address whitelisted . To do this, please contact Tom T. over Discord ( Tom T#7603 ), Telegram ( @TampaBay7 ) or email ( tom@flare.network ) and request to be whitelisted. Checking the status of your whitelisting request You can also check the status of your request by running: Flare Songbird curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' \\ https://flare.flare.network/ext/info curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' \\ https://songbird.flare.network/ext/info If your IP address is whitelisted, this command returns a JSON response. Otherwise you will get a 403 error (\"Forbidden\"). Please note that whitelisting is not needed on the Coston and Coston 2 networks . 3. Run the Node # This is the minimum command to quickly get your node up and running. To understand each parameter read the following step before launching the node. Flare Songbird Coston Coston 2 ./build/avalanchego --network-id = flare --http-host = \\ --bootstrap-ips = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' https://flare.flare.network/ext/info \\ | jq -r \".result.ip\" ) \" \\ --bootstrap-ids = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' https://flare.flare.network/ext/info \\ | jq -r \".result.nodeID\" ) \" ./build/flare --network-id = songbird --http-host = \\ --bootstrap-ips = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' https://songbird.flare.network/ext/info \\ | jq -r \".result.ip\" ) \" \\ --bootstrap-ids = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' https://songbird.flare.network/ext/info \\ | jq -r \".result.nodeID\" ) \" ./build/flare --network-id = coston --http-host = \\ --bootstrap-ips = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' https://coston.flare.network/ext/info \\ | jq -r \".result.ip\" ) \" \\ --bootstrap-ids = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' https://coston.flare.network/ext/info \\ | jq -r \".result.nodeID\" ) \" ./build/avalanchego --network-id = costwo --http-host = \\ --bootstrap-ips = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' https://coston2.flare.network/ext/info \\ | jq -r \".result.ip\" ) \" \\ --bootstrap-ids = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' https://coston2.flare.network/ext/info \\ | jq -r \".result.nodeID\" ) \" After a lot of log messages the node should start synchronizing with the network, which might take a long time (currently about 4 hours for Flare, over a week for Songbird, depending on network speed and machine specs). You can stop the node at any time by pressing Ctrl-C . Use the same command line as before to restart the node. Synchronization will resume where it left if it is interrupted. You will know your node is fully booted and accepting transactions when the output of this command: curl http://127.0.0.1:9650/ext/health Contains the field \"healthy\":true in the returned JSON object. Note If the node gets stuck during bootstrap (it takes far longer than the estimates given above), try to add the parameter --bootstrap-retry-enabled=false . 4. Additional Configuration # These are some of the most relevant command line parameters you can use. You can read about all of them in the Avalanche documentation . --bootstrap-ips , --bootstrap-ids : IP address and node ID of the peer used to connect to the rest of the network for bootstrapping. You can use Flare's public nodes for this, as shown in the quick start command given above: Flare Songbird Coston Coston 2 Peer's IP address: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' \\ https://flare.flare.network/ext/info | jq -r \".result.ip\" Peer's node ID: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' \\ https://flare.flare.network/ext/info | jq -r \".result.nodeID\" Peer's IP address: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' \\ https://songbird.flare.network/ext/info | jq -r \".result.ip\" Peer's node ID: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' \\ https://songbird.flare.network/ext/info | jq -r \".result.nodeID\" Peer's IP address: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' \\ https://coston.flare.network/ext/info | jq -r \".result.ip\" Peer's node ID: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' \\ https://coston.flare.network/ext/info | jq -r \".result.nodeID\" Peer's IP address: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' \\ https://coston2.flare.network/ext/info | jq -r \".result.ip\" Peer's node ID: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' \\ https://coston2.flare.network/ext/info | jq -r \".result.nodeID\" Remember that you need to whitelist your node's IP address or your queries will always be answered with 403 error codes. --http-host : Use --http-host= (empty) to allow connections from other machines. Otherwise, only connections from localhost are accepted. --http-port : The port through which the node will listen to API requests. The default value is 9650 . --staking-port : The port through which the network peers will connect to this node externally. Having this port accessible from the internet is required for correct node operation. The default value is 9651 . --db-dir : Directory where the database is stored. Make sure to use a disk with enough space as recommended in the Hardware prerequisites section. It defaults to ~/.avalanchego/db on Flare and Coston 2, and to ~/.flare/db on Songbird and Coston. You can use this option to store the database on an external drive, for example. --pruning-enabled : Enables pruning of old transactions, greatly reducing disk size requirements. It defaults to true . It you want to create a so-called archival node , i.e., one that keeps the whole history of the blockchain, set this parameter to false . --chain-config-dir : Optional JSON configuration file, in case you want to use lots of non-default values. Sample configuration file for observation nodes These are the most common configuration options. Put them in a file in the {chain-config-dir}/C/config.json folder. { \"snowman-api-enabled\" : false , \"coreth-admin-api-enabled\" : false , \"eth-apis\" : [ \"public-eth\" , \"public-eth-filter\" , \"net\" , \"web3\" , \"internal-public-eth\" , \"internal-public-blockchain\" , \"internal-public-transaction-pool\" ], \"rpc-gas-cap\" : 50000000 , \"rpc-tx-fee-cap\" : 100 , \"pruning-enabled\" : true , \"local-txs-enabled\" : false , \"api-max-duration\" : 0 , \"api-max-blocks-per-request\" : 0 , \"allow-unfinalized-queries\" : false , \"allow-unprotected-txs\" : false , \"remote-tx-gossip-only-enabled\" : false , \"log-level\" : \"info\" }","title":"Deploying an Observation Node"},{"location":"infra/observation/deploying/#deploying-an-observation-node","text":"","title":"Deploying an Observation Node"},{"location":"infra/observation/deploying/#introduction","text":"Observation nodes enable anyone to observe the network and submit transactions. Unlike validator nodes , which provide state consensus and add blocks, observation nodes remain outside the network and have no effect on consensus or blocks. Running an observation node is optional. However, submitting transactions through your own node offers a number of benefits: Transactions are sent directly to the network instead of through a third party, removing a potential security risk. Public nodes are usually rate-limited (the amount of requests they accept per second is restricted). Your own node does not have such restriction. The time savings described above allow FTSO data providers to submit their data a few seconds later, thus having more time to gather price data before submitting. This guide explains how to deploy your own observation node so you can reap these benefits.","title":"Introduction"},{"location":"infra/observation/deploying/#prerequisites","text":"This guide contains different instructions depending on which Flare Network you want to deploy to, so make sure you are aware of the available networks . Flare Songbird Coston Coston 2 Hardware Software CPU cores 8 Operating System Ubuntu (18.04 or 20.04) or macOS (>= 10.15 Catalina) RAM 32 Dependencies Go (>= 1.18.5) Disk space 1 TB SSD gcc Disk growth 2.5 TB/year g++ jq Hardware Software CPU cores 8 Operating System Ubuntu (18.04 or 20.04) or macOS (>= 10.15 Catalina) RAM 32 Dependencies Go (>= 1.16.8) Disk space 3.5 TB SSD gcc Disk growth 2.5 TB/year g++ jq Hardware Software CPU cores 4 Operating System Ubuntu (18.04 or 20.04) or macOS (>= 10.15 Catalina) RAM 16 Dependencies Go (>= 1.16.8) Disk space 500 GB SSD gcc Disk growth 250 GB/year g++ jq Hardware Software CPU cores 4 Operating System Ubuntu (18.04 or 20.04) or macOS (>= 10.15 Catalina) RAM 16 Dependencies Go (>= 1.18.5) Disk space 500 GB SSD gcc Disk growth 250 GB/year g++ jq Plus a reliable IPv4 or IPv6 network connection, with an open public port. Keep in mind that enabling pruning as described below can reduce the required disk space by as much as 60%.","title":"Prerequisites"},{"location":"infra/observation/deploying/#guide","text":"","title":"Guide"},{"location":"infra/observation/deploying/#1-installation","text":"Flare & Coston 2 Songbird & Coston Clone the go-flare repository and run the build.sh script: git clone https://github.com/flare-foundation/go-flare.git cd go-flare/avalanchego ./scripts/build.sh The resulting executable will be build/avalanchego . Note You can verify the installation by running: go test $( go list ./... | grep -v /tests/ ) # avalanchego unit tests cd ../coreth go test ./... # coreth unit tests cd ../avalanchego Clone the go-songbird repository and run the build.sh script: git clone https://github.com/flare-foundation/go-songbird.git cd go-songbird ./scripts/build.sh The resulting executable will be build/flare . Note You can verify the installation by running: go test $( go list ./... | grep -v /tests/ ) # avalanchego unit tests cd coreth go test ./... # coreth unit tests cd ..","title":"1. Installation"},{"location":"infra/observation/deploying/#2-node-whitelisting","text":"While the Flare and Songbird networks are being tested, all nodes wanting to peer with them (including observation nodes) need to have their IP address whitelisted . To do this, please contact Tom T. over Discord ( Tom T#7603 ), Telegram ( @TampaBay7 ) or email ( tom@flare.network ) and request to be whitelisted. Checking the status of your whitelisting request You can also check the status of your request by running: Flare Songbird curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' \\ https://flare.flare.network/ext/info curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' \\ https://songbird.flare.network/ext/info If your IP address is whitelisted, this command returns a JSON response. Otherwise you will get a 403 error (\"Forbidden\"). Please note that whitelisting is not needed on the Coston and Coston 2 networks .","title":"2. Node Whitelisting"},{"location":"infra/observation/deploying/#3-run-the-node","text":"This is the minimum command to quickly get your node up and running. To understand each parameter read the following step before launching the node. Flare Songbird Coston Coston 2 ./build/avalanchego --network-id = flare --http-host = \\ --bootstrap-ips = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' https://flare.flare.network/ext/info \\ | jq -r \".result.ip\" ) \" \\ --bootstrap-ids = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' https://flare.flare.network/ext/info \\ | jq -r \".result.nodeID\" ) \" ./build/flare --network-id = songbird --http-host = \\ --bootstrap-ips = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' https://songbird.flare.network/ext/info \\ | jq -r \".result.ip\" ) \" \\ --bootstrap-ids = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' https://songbird.flare.network/ext/info \\ | jq -r \".result.nodeID\" ) \" ./build/flare --network-id = coston --http-host = \\ --bootstrap-ips = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' https://coston.flare.network/ext/info \\ | jq -r \".result.ip\" ) \" \\ --bootstrap-ids = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' https://coston.flare.network/ext/info \\ | jq -r \".result.nodeID\" ) \" ./build/avalanchego --network-id = costwo --http-host = \\ --bootstrap-ips = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' https://coston2.flare.network/ext/info \\ | jq -r \".result.ip\" ) \" \\ --bootstrap-ids = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' https://coston2.flare.network/ext/info \\ | jq -r \".result.nodeID\" ) \" After a lot of log messages the node should start synchronizing with the network, which might take a long time (currently about 4 hours for Flare, over a week for Songbird, depending on network speed and machine specs). You can stop the node at any time by pressing Ctrl-C . Use the same command line as before to restart the node. Synchronization will resume where it left if it is interrupted. You will know your node is fully booted and accepting transactions when the output of this command: curl http://127.0.0.1:9650/ext/health Contains the field \"healthy\":true in the returned JSON object. Note If the node gets stuck during bootstrap (it takes far longer than the estimates given above), try to add the parameter --bootstrap-retry-enabled=false .","title":"3. Run the Node"},{"location":"infra/observation/deploying/#4-additional-configuration","text":"These are some of the most relevant command line parameters you can use. You can read about all of them in the Avalanche documentation . --bootstrap-ips , --bootstrap-ids : IP address and node ID of the peer used to connect to the rest of the network for bootstrapping. You can use Flare's public nodes for this, as shown in the quick start command given above: Flare Songbird Coston Coston 2 Peer's IP address: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' \\ https://flare.flare.network/ext/info | jq -r \".result.ip\" Peer's node ID: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' \\ https://flare.flare.network/ext/info | jq -r \".result.nodeID\" Peer's IP address: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' \\ https://songbird.flare.network/ext/info | jq -r \".result.ip\" Peer's node ID: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' \\ https://songbird.flare.network/ext/info | jq -r \".result.nodeID\" Peer's IP address: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' \\ https://coston.flare.network/ext/info | jq -r \".result.ip\" Peer's node ID: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' \\ https://coston.flare.network/ext/info | jq -r \".result.nodeID\" Peer's IP address: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' \\ https://coston2.flare.network/ext/info | jq -r \".result.ip\" Peer's node ID: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' \\ https://coston2.flare.network/ext/info | jq -r \".result.nodeID\" Remember that you need to whitelist your node's IP address or your queries will always be answered with 403 error codes. --http-host : Use --http-host= (empty) to allow connections from other machines. Otherwise, only connections from localhost are accepted. --http-port : The port through which the node will listen to API requests. The default value is 9650 . --staking-port : The port through which the network peers will connect to this node externally. Having this port accessible from the internet is required for correct node operation. The default value is 9651 . --db-dir : Directory where the database is stored. Make sure to use a disk with enough space as recommended in the Hardware prerequisites section. It defaults to ~/.avalanchego/db on Flare and Coston 2, and to ~/.flare/db on Songbird and Coston. You can use this option to store the database on an external drive, for example. --pruning-enabled : Enables pruning of old transactions, greatly reducing disk size requirements. It defaults to true . It you want to create a so-called archival node , i.e., one that keeps the whole history of the blockchain, set this parameter to false . --chain-config-dir : Optional JSON configuration file, in case you want to use lots of non-default values. Sample configuration file for observation nodes These are the most common configuration options. Put them in a file in the {chain-config-dir}/C/config.json folder. { \"snowman-api-enabled\" : false , \"coreth-admin-api-enabled\" : false , \"eth-apis\" : [ \"public-eth\" , \"public-eth-filter\" , \"net\" , \"web3\" , \"internal-public-eth\" , \"internal-public-blockchain\" , \"internal-public-transaction-pool\" ], \"rpc-gas-cap\" : 50000000 , \"rpc-tx-fee-cap\" : 100 , \"pruning-enabled\" : true , \"local-txs-enabled\" : false , \"api-max-duration\" : 0 , \"api-max-blocks-per-request\" : 0 , \"allow-unfinalized-queries\" : false , \"allow-unprotected-txs\" : false , \"remote-tx-gossip-only-enabled\" : false , \"log-level\" : \"info\" }","title":"4. Additional Configuration"},{"location":"infra/observation/faq/","text":"FAQ # Do I need to re-whitelist my peering node IP? # No, you do not need to re-whitelist the IP address. I want to have greater redundancy and would like to whitelist multiple nodes, can I do that? # Yes, you can whitelist multiple IPs per single provider. Can an unhealthy node cause my transactions to revert? # Yes, at times, not enough connected peers can cause your transactions to revert. Make sure your node state is healthy and that it has enough connected peers. How do I check the number of connected peers? # curl http://127.0.0.1:9650/ext/health | jq And look for the line containing connectedPeers . If you want to automate the process you can use: curl -s http://127.0.0.1:9650/ext/health | \\ jq -r \".checks.network.message.connectedPeers\" What is the required number of connected peers? # If the number of peers falls below 16, chances are your node will not work correctly. While the network is being decentralized, any number below 20 is indication of a problem. In any case, try restarting the node. The node does not sync after a long time and dies abruptly, what should I do? # Make sure, that the database location has sufficient disk space (database size might change a lot during bootstrapping). I am getting strange errors on submission and revert messages are cryptic # This might be a symptom of a node connection error. Try to restart the node and make sure you have enough disk space. I am getting a strange error related to GetAcceptedFrontier during bootstrapping # failed to send GetAcceptedFrontier(MtF8bVH241hetCQJgsKEdKyJBs8vhp1BC, 11111111111111111111111111111111LpoYY, NUMBER) It looks like your node got disconnected during bootstrapping. Try restarting the node. I have synced the node but it does not become healthy. What can I do? # It often happens that a new node gets synced but stays unhealthy for no apparent reason. A restart usually helps.","title":"FAQ"},{"location":"infra/observation/faq/#faq","text":"","title":"FAQ"},{"location":"infra/observation/faq/#do-i-need-to-re-whitelist-my-peering-node-ip","text":"No, you do not need to re-whitelist the IP address.","title":"Do I need to re-whitelist my peering node IP?"},{"location":"infra/observation/faq/#i-want-to-have-greater-redundancy-and-would-like-to-whitelist-multiple-nodes-can-i-do-that","text":"Yes, you can whitelist multiple IPs per single provider.","title":"I want to have greater redundancy and would like to whitelist multiple nodes, can I do that?"},{"location":"infra/observation/faq/#can-an-unhealthy-node-cause-my-transactions-to-revert","text":"Yes, at times, not enough connected peers can cause your transactions to revert. Make sure your node state is healthy and that it has enough connected peers.","title":"Can an unhealthy node cause my transactions to revert?"},{"location":"infra/observation/faq/#how-do-i-check-the-number-of-connected-peers","text":"curl http://127.0.0.1:9650/ext/health | jq And look for the line containing connectedPeers . If you want to automate the process you can use: curl -s http://127.0.0.1:9650/ext/health | \\ jq -r \".checks.network.message.connectedPeers\"","title":"How do I check the number of connected peers?"},{"location":"infra/observation/faq/#what-is-the-required-number-of-connected-peers","text":"If the number of peers falls below 16, chances are your node will not work correctly. While the network is being decentralized, any number below 20 is indication of a problem. In any case, try restarting the node.","title":"What is the required number of connected peers?"},{"location":"infra/observation/faq/#the-node-does-not-sync-after-a-long-time-and-dies-abruptly-what-should-i-do","text":"Make sure, that the database location has sufficient disk space (database size might change a lot during bootstrapping).","title":"The node does not sync after a long time and dies abruptly, what should I do?"},{"location":"infra/observation/faq/#i-am-getting-strange-errors-on-submission-and-revert-messages-are-cryptic","text":"This might be a symptom of a node connection error. Try to restart the node and make sure you have enough disk space.","title":"I am getting strange errors on submission and revert messages are cryptic"},{"location":"infra/observation/faq/#i-am-getting-a-strange-error-related-to-getacceptedfrontier-during-bootstrapping","text":"failed to send GetAcceptedFrontier(MtF8bVH241hetCQJgsKEdKyJBs8vhp1BC, 11111111111111111111111111111111LpoYY, NUMBER) It looks like your node got disconnected during bootstrapping. Try restarting the node.","title":"I am getting a strange error related to GetAcceptedFrontier during bootstrapping"},{"location":"infra/observation/faq/#i-have-synced-the-node-but-it-does-not-become-healthy-what-can-i-do","text":"It often happens that a new node gets synced but stays unhealthy for no apparent reason. A restart usually helps.","title":"I have synced the node but it does not become healthy. What can I do?"},{"location":"infra/validation/deploying/","text":"Deploying a Validation Node # Introduction # As explained in the Validator Nodes page, these servers fulfill a critical role in securing the network: They check that all received transactions are valid. They run a consensus algorithm so that all validators in the network agree on the transactions to add to the blockchain. Finally, they add the agreed-upon transactions to their copy of the ledger . This guide explains how to deploy your own validator node so you can participate in the consensus and collect the rewards that the network provides to those who help secure it. Only validators with preregistered keys can be deployed at the moment Some users might have received preregistered validator keys , this is, the keys required to launch a node which has already been registered as a validator . This is the only way to deploy a validator node at this time. The procedure for self-registration of validators is being finished and will be available soon to the whole community. When that happens this page will be updated. The following instructions apply to the Flare network only. Prerequisites # Validators run the same software as regular observation nodes , therefore, this guide assumes you have already read the Deploying an Observation Node guide. The requirements to deploy a validator node are the same as for observation nodes, except on the CPU and RAM front which are heavier due to the extra work required: Hardware Software CPU cores 16 Operating System Ubuntu (18.04 or 20.04) or macOS (>= 10.15 Catalina) RAM 64 Dependencies Go (>= 1.18.5) Disk space 1 TB SSD gcc Disk growth 2.5 TB/year g++ jq Guide # 1. Configure the Node # A validator node is deployed like an observation node, but there are some things to consider first. Validators do more work than plain observation nodes so please consider the recommended hardware specifications above. Validator security impacts the whole network. Please consider the following items carefully: Have the machine firewalled . Only the ports required for validator operation should be open (i.e., only the staking port, which defaults to 9651). If you use a virtual server, use only its web interface for management and close the SSH port. If the SSH port must be open, it should ideally be restricted to a private IP (i.e. only accessible through VPN) or only temporarily open to the operator's office/home static IP or a bastion SSH VM that can be turned off between use. The node should only act as validator , and not accept RPC API calls too. You should deploy a separate observation node for that task, which can point to your validator for peering and bootstrapping. The validator should only enable the minimum set of EVM APIs by adding this line to a configuration file : \"eth-apis\" : [ \"web3\" ] Sample configuration file for validator nodes { \"snowman-api-enabled\" : false , \"coreth-admin-api-enabled\" : false , \"coreth-admin-api-dir\" : \"\" , \"eth-apis\" : [ \"web3\" ], \"continuous-profiler-dir\" : \"\" , \"continuous-profiler-frequency\" : 900000000000 , \"continuous-profiler-max-files\" : 5 , \"rpc-gas-cap\" : 50000000 , \"rpc-tx-fee-cap\" : 100 , \"preimages-enabled\" : false , \"pruning-enabled\" : false , \"snapshot-async\" : true , \"snapshot-verification-enabled\" : false , \"metrics-enabled\" : true , \"metrics-expensive-enabled\" : false , \"local-txs-enabled\" : false , \"api-max-duration\" : 30000000000 , \"ws-cpu-refill-rate\" : 0 , \"ws-cpu-max-stored\" : 0 , \"api-max-blocks-per-request\" : 30 , \"allow-unfinalized-queries\" : false , \"allow-unprotected-txs\" : false , \"keystore-directory\" : \"\" , \"keystore-external-signer\" : \"\" , \"keystore-insecure-unlock-allowed\" : false , \"remote-tx-gossip-only-enabled\" : false , \"tx-regossip-frequency\" : 60000000000 , \"tx-regossip-max-size\" : 15 , \"log-level\" : \"info\" , \"offline-pruning-enabled\" : false , \"offline-pruning-bloom-filter-size\" : 512 , \"offline-pruning-data-directory\" : \"\" } Preregistered validator keys Some users might have received preregistered validator keys , this is, the keys required to deploy a node which has already been registered as a validator. If that is your case, you need to add these parameters to the launch command line: --staking-tls-cert-file = <NODE_CRT_PATH> --staking-tls-key-file = <NODE_KEY_PATH> 2. Run the Node # After taking the above considerations into account, you can now start up your node by following the Deploying an Observation Node guide.","title":"Deploying a Validation Node"},{"location":"infra/validation/deploying/#deploying-a-validation-node","text":"","title":"Deploying a Validation Node"},{"location":"infra/validation/deploying/#introduction","text":"As explained in the Validator Nodes page, these servers fulfill a critical role in securing the network: They check that all received transactions are valid. They run a consensus algorithm so that all validators in the network agree on the transactions to add to the blockchain. Finally, they add the agreed-upon transactions to their copy of the ledger . This guide explains how to deploy your own validator node so you can participate in the consensus and collect the rewards that the network provides to those who help secure it. Only validators with preregistered keys can be deployed at the moment Some users might have received preregistered validator keys , this is, the keys required to launch a node which has already been registered as a validator . This is the only way to deploy a validator node at this time. The procedure for self-registration of validators is being finished and will be available soon to the whole community. When that happens this page will be updated. The following instructions apply to the Flare network only.","title":"Introduction"},{"location":"infra/validation/deploying/#prerequisites","text":"Validators run the same software as regular observation nodes , therefore, this guide assumes you have already read the Deploying an Observation Node guide. The requirements to deploy a validator node are the same as for observation nodes, except on the CPU and RAM front which are heavier due to the extra work required: Hardware Software CPU cores 16 Operating System Ubuntu (18.04 or 20.04) or macOS (>= 10.15 Catalina) RAM 64 Dependencies Go (>= 1.18.5) Disk space 1 TB SSD gcc Disk growth 2.5 TB/year g++ jq","title":"Prerequisites"},{"location":"infra/validation/deploying/#guide","text":"","title":"Guide"},{"location":"infra/validation/deploying/#1-configure-the-node","text":"A validator node is deployed like an observation node, but there are some things to consider first. Validators do more work than plain observation nodes so please consider the recommended hardware specifications above. Validator security impacts the whole network. Please consider the following items carefully: Have the machine firewalled . Only the ports required for validator operation should be open (i.e., only the staking port, which defaults to 9651). If you use a virtual server, use only its web interface for management and close the SSH port. If the SSH port must be open, it should ideally be restricted to a private IP (i.e. only accessible through VPN) or only temporarily open to the operator's office/home static IP or a bastion SSH VM that can be turned off between use. The node should only act as validator , and not accept RPC API calls too. You should deploy a separate observation node for that task, which can point to your validator for peering and bootstrapping. The validator should only enable the minimum set of EVM APIs by adding this line to a configuration file : \"eth-apis\" : [ \"web3\" ] Sample configuration file for validator nodes { \"snowman-api-enabled\" : false , \"coreth-admin-api-enabled\" : false , \"coreth-admin-api-dir\" : \"\" , \"eth-apis\" : [ \"web3\" ], \"continuous-profiler-dir\" : \"\" , \"continuous-profiler-frequency\" : 900000000000 , \"continuous-profiler-max-files\" : 5 , \"rpc-gas-cap\" : 50000000 , \"rpc-tx-fee-cap\" : 100 , \"preimages-enabled\" : false , \"pruning-enabled\" : false , \"snapshot-async\" : true , \"snapshot-verification-enabled\" : false , \"metrics-enabled\" : true , \"metrics-expensive-enabled\" : false , \"local-txs-enabled\" : false , \"api-max-duration\" : 30000000000 , \"ws-cpu-refill-rate\" : 0 , \"ws-cpu-max-stored\" : 0 , \"api-max-blocks-per-request\" : 30 , \"allow-unfinalized-queries\" : false , \"allow-unprotected-txs\" : false , \"keystore-directory\" : \"\" , \"keystore-external-signer\" : \"\" , \"keystore-insecure-unlock-allowed\" : false , \"remote-tx-gossip-only-enabled\" : false , \"tx-regossip-frequency\" : 60000000000 , \"tx-regossip-max-size\" : 15 , \"log-level\" : \"info\" , \"offline-pruning-enabled\" : false , \"offline-pruning-bloom-filter-size\" : 512 , \"offline-pruning-data-directory\" : \"\" } Preregistered validator keys Some users might have received preregistered validator keys , this is, the keys required to deploy a node which has already been registered as a validator. If that is your case, you need to add these parameters to the launch command line: --staking-tls-cert-file = <NODE_CRT_PATH> --staking-tls-key-file = <NODE_KEY_PATH>","title":"1. Configure the Node"},{"location":"infra/validation/deploying/#2-run-the-node","text":"After taking the above considerations into account, you can now start up your node by following the Deploying an Observation Node guide.","title":"2. Run the Node"},{"location":"tech/","text":"Concepts # This section contains in-depth descriptions of Flare's key concepts and tools.","title":"Concepts"},{"location":"tech/#concepts","text":"This section contains in-depth descriptions of Flare's key concepts and tools.","title":"Concepts"},{"location":"tech/api-portal/","text":"Flare API Portal # Flare's API Portal is a paid product that gives developers access to a number of private nodes running on different blockchains, including Flare, Songbird and Coston , but also other networks like Bitcoin or XRPL. These nodes are not rate-limited , so it is typically more convenient to connect your apps to them than to deploy your own nodes, or connect to public nodes. This is one more step towards Flare's goal to connect all blockchains . Visit Flare's API Portal website","title":"Flare API Portal"},{"location":"tech/api-portal/#flare-api-portal","text":"Flare's API Portal is a paid product that gives developers access to a number of private nodes running on different blockchains, including Flare, Songbird and Coston , but also other networks like Bitcoin or XRPL. These nodes are not rate-limited , so it is typically more convenient to connect your apps to them than to deploy your own nodes, or connect to public nodes. This is one more step towards Flare's goal to connect all blockchains . Visit Flare's API Portal website","title":"Flare API Portal"},{"location":"tech/flare-launch-process/","text":"Flare Launch Process # The Flare launch is delicate, as it involves a rather large airdrop , a community vote , and the deployment of a novel meritocratic consensus system. For this reason, it has been divided into a series of sequential phases with clearly-defined triggers that signal each transition. The main goal of this page is to remove any confusion around the launch process by clearly describing the purpose of each phase and what happens in them. The secondary goal is to serve as a real-time tracker of the current phase . Without further ado: Click on a phase to navigate to its description. Definitions # Some definitions are required so the rest of the page is clear and unambiguous. FIP.01 : A governance proposal that, among other things, changes the initial token distributions as explained below. This proposal needs to be voted on according to the schedule described in this page. Flare Airdrop for XRP Holders : Certain holders of XRP tokens on Dec 12, 2020, were eligible to register for the FLR token distribution (then called Spark tokens) once the Flare network launched. The claiming process is described in this (slightly outdated) Flare blog post . The FIP.01 proposal modifies the way in which the airdrop works. Original Airdrop : 28.53B FLR tokens, which in the original distribution plan went to those who registered for the distribution. New Airdrop : 4.28B FLR tokens destined for those that registered for the distribution. Delegation Incentive Pool (DIP) : 24.25B FLR tokens destined for any Flare holder that participates in the network over 36 months as per the FIP.01 distribution plan. Note that the New Airdrop plus the DIP match the Original Airdrop. Token Distribution Event (TDE) : The moment when the initial FLR tokens are distributed to those that registered for the FLR token distribution. These tokens were minted and locked when the network was created and will be released when it is sufficiently decentralized. Token Distribution Plans # It is worth summarizing the two current token distribution plans, as only one of them will be implemented depending on whether FIP.01 is approved or not. Original Distribution Plan : 15% of the original airdrop is sent to those that registered for the FLR distribution upon the TDE, with the rest delivered monthly over the following 30 months. Inflation is 10% of the fully diluted supply, per annum. FIP.01 Distribution Plan : The new airdrop is sent to those that registered for the FLR distribution upon the TDE, the DIP will be distributed to ALL FLR token holders (actually, wrapped FLR holders) over 36 months (Flare employees and companies excluded). Inflation is 10% of available supply in the first year, then 7% the following year, 5% the year after and in perpetuity, except that from year 3 onwards inflation is capped at 5bn FLR per year. Inflation distribution: 70% to FTSO rewards, 20% to validator rewards and 10% to the default Attestation Provider Set of the state connector . Flare Beta # Decentralization will be achieved by moving the transaction validation duty from the Flare Foundation to community-run FTSO data providers , but this will not happen instantly. Instead, in order to ensure a safe transition, a number of professional validators will be initially employed. The professional validators will be chosen among companies with proven experience running blockchain infrastructure, and will at first hold most of the validation power . This power, though, will be progressively shifted onto the community-run validators until they run the network on their own. This initial period is called Flare Beta , and it will span several launch phases (marked in blue in the diagram above). Flare Beta Details # During this period: There are 22 total validators with equal validation power (20K FLR each, initially). 4 run by the Flare Foundation. 16 run by 4 professional validators. 2 \"virtual validators\" collectively run by ALL FTSO data providers together. FTSO data providers have their initial validation power artificially reduced so that all of them combined have the power of two validators (i.e. 40K FLR tokens). Validator rewards (20% of inflation) are split 50% for the professional validators and 50% for the FTSO data providers. The validation power for each FTSO validator will be calculated monthly by an external script (public, auditable and based on on-chain data) and shared among all validators. Each FTSO's share of validation power will depend on its FTSO performance and its own stake, as is done with the voting power used in the normal FTSO operation . The total validation power allocated for FTSO will start at 40K FLR but will gradually increase until it matches the real stake each FTSO has (including delegations). Validation rewards for FTSOs will increase accordingly as their collective validation power increases. Estimated duration: 6-9 months, depending on the evolution of the network. Launch Phases # Private Observation Mode # Trigger: The Flare network Launches On July 14th 2022 the network started centralized, with only 21 validators, run by the Flare Foundation. Flare validator source code is not available yet. FTSO data providers: Can submit prices, as they do on Songbird, but don't act as validators since they cannot run nodes. Are not rewarded. All inflation is burned during observation mode . Public Observation Mode # Trigger: The Flare validator source code becomes publicly available Professional validators start onboarding, so the network stars becoming decentralized. FTSO data providers: Can submit prices, as they do on Songbird, but don't act as validators since they won't have funds to stake until the TDE. Are not rewarded. All inflation is burned during observation mode . Initial Distribution Period # Trigger: 66% of validator power is independent of Flare, AND Exchanges agree to distribute the FLR token to their customers within a few days of the TDE Token Distribution Event (TDE) happens The new airdrop is sent to the Flare addresses provided by XRP token holders when they claimed. Part of the airdrop is expected to go to Exchange accounts, which will then distribute it to the users that originally claimed (the intended recipients ). Flare will monitor how many of the airdrop tokens have reached the intended recipients, by following the Exchange's communication channels. FTSO data providers: Can now deploy their own validator nodes. The guide to do so will be available. Act as validators and their voting power depends on their FTSO performance and stake . FTSO and validator rewards are enabled. Inflation is not burned anymore. FIP.01 Notice Period # Trigger: 66% of the new airdrop reaches its intended recipients The FIP.01 proposal modifies how the rest of the tokens (after the TDE) are to be distributed, so it needs to be voted on by the community. Users will vote with their FLR token stake, so voting cannot start until enough tokens have reached the intended recipients. Once 66% of the FLR tokens distributed during the TDE reach these users, a 1-week notice period will start. Flare will announce to the community that enough tokens have been distributed and the notice period has started. FIP.01 Voting Period # Trigger: 1 week after Notice Period starts All FLR token holders (obtained either from the new airdrop or bought at Exchanges) can vote on FIP.01 using the voting frontend . Flare will announce to the community that the Voting Period has started and relay instructions on how to vote. Voting Period will last 1 week. Regular Operation (Beta) # Trigger: FIP.01 is approved after 1 week of voting The changes proposed in FIP.01 are implemented . The DIP is distributed to ALL holders of FLR during 37 months. Flare Beta is still in operation but community-run validators gradually gain more power. Regular Operation # Trigger: Community-run FTSO validators are deemed reliable enough Flare Beta ends. FTSO validators's validation power is not artificially reduced anymore and validator rewards (20% of inflation) are distributed equally among all validators according to their performance and stake. Regular Non-FIP.01 Operation # Trigger: FIP.01 is NOT approved after 1 week of voting The Original Distribution Plan is implemented.","title":"Flare Launch Process"},{"location":"tech/flare-launch-process/#flare-launch-process","text":"The Flare launch is delicate, as it involves a rather large airdrop , a community vote , and the deployment of a novel meritocratic consensus system. For this reason, it has been divided into a series of sequential phases with clearly-defined triggers that signal each transition. The main goal of this page is to remove any confusion around the launch process by clearly describing the purpose of each phase and what happens in them. The secondary goal is to serve as a real-time tracker of the current phase . Without further ado: Click on a phase to navigate to its description.","title":"Flare Launch Process"},{"location":"tech/flare-launch-process/#definitions","text":"Some definitions are required so the rest of the page is clear and unambiguous. FIP.01 : A governance proposal that, among other things, changes the initial token distributions as explained below. This proposal needs to be voted on according to the schedule described in this page. Flare Airdrop for XRP Holders : Certain holders of XRP tokens on Dec 12, 2020, were eligible to register for the FLR token distribution (then called Spark tokens) once the Flare network launched. The claiming process is described in this (slightly outdated) Flare blog post . The FIP.01 proposal modifies the way in which the airdrop works. Original Airdrop : 28.53B FLR tokens, which in the original distribution plan went to those who registered for the distribution. New Airdrop : 4.28B FLR tokens destined for those that registered for the distribution. Delegation Incentive Pool (DIP) : 24.25B FLR tokens destined for any Flare holder that participates in the network over 36 months as per the FIP.01 distribution plan. Note that the New Airdrop plus the DIP match the Original Airdrop. Token Distribution Event (TDE) : The moment when the initial FLR tokens are distributed to those that registered for the FLR token distribution. These tokens were minted and locked when the network was created and will be released when it is sufficiently decentralized.","title":"Definitions"},{"location":"tech/flare-launch-process/#token-distribution-plans","text":"It is worth summarizing the two current token distribution plans, as only one of them will be implemented depending on whether FIP.01 is approved or not. Original Distribution Plan : 15% of the original airdrop is sent to those that registered for the FLR distribution upon the TDE, with the rest delivered monthly over the following 30 months. Inflation is 10% of the fully diluted supply, per annum. FIP.01 Distribution Plan : The new airdrop is sent to those that registered for the FLR distribution upon the TDE, the DIP will be distributed to ALL FLR token holders (actually, wrapped FLR holders) over 36 months (Flare employees and companies excluded). Inflation is 10% of available supply in the first year, then 7% the following year, 5% the year after and in perpetuity, except that from year 3 onwards inflation is capped at 5bn FLR per year. Inflation distribution: 70% to FTSO rewards, 20% to validator rewards and 10% to the default Attestation Provider Set of the state connector .","title":"Token Distribution Plans"},{"location":"tech/flare-launch-process/#flare-beta","text":"Decentralization will be achieved by moving the transaction validation duty from the Flare Foundation to community-run FTSO data providers , but this will not happen instantly. Instead, in order to ensure a safe transition, a number of professional validators will be initially employed. The professional validators will be chosen among companies with proven experience running blockchain infrastructure, and will at first hold most of the validation power . This power, though, will be progressively shifted onto the community-run validators until they run the network on their own. This initial period is called Flare Beta , and it will span several launch phases (marked in blue in the diagram above).","title":"Flare Beta"},{"location":"tech/flare-launch-process/#flare-beta-details","text":"During this period: There are 22 total validators with equal validation power (20K FLR each, initially). 4 run by the Flare Foundation. 16 run by 4 professional validators. 2 \"virtual validators\" collectively run by ALL FTSO data providers together. FTSO data providers have their initial validation power artificially reduced so that all of them combined have the power of two validators (i.e. 40K FLR tokens). Validator rewards (20% of inflation) are split 50% for the professional validators and 50% for the FTSO data providers. The validation power for each FTSO validator will be calculated monthly by an external script (public, auditable and based on on-chain data) and shared among all validators. Each FTSO's share of validation power will depend on its FTSO performance and its own stake, as is done with the voting power used in the normal FTSO operation . The total validation power allocated for FTSO will start at 40K FLR but will gradually increase until it matches the real stake each FTSO has (including delegations). Validation rewards for FTSOs will increase accordingly as their collective validation power increases. Estimated duration: 6-9 months, depending on the evolution of the network.","title":"Flare Beta Details"},{"location":"tech/flare-launch-process/#launch-phases","text":"","title":"Launch Phases"},{"location":"tech/flare-launch-process/#private-observation-mode","text":"Trigger: The Flare network Launches On July 14th 2022 the network started centralized, with only 21 validators, run by the Flare Foundation. Flare validator source code is not available yet. FTSO data providers: Can submit prices, as they do on Songbird, but don't act as validators since they cannot run nodes. Are not rewarded. All inflation is burned during observation mode .","title":"Private Observation Mode"},{"location":"tech/flare-launch-process/#public-observation-mode","text":"Trigger: The Flare validator source code becomes publicly available Professional validators start onboarding, so the network stars becoming decentralized. FTSO data providers: Can submit prices, as they do on Songbird, but don't act as validators since they won't have funds to stake until the TDE. Are not rewarded. All inflation is burned during observation mode .","title":"Public Observation Mode"},{"location":"tech/flare-launch-process/#initial-distribution-period","text":"Trigger: 66% of validator power is independent of Flare, AND Exchanges agree to distribute the FLR token to their customers within a few days of the TDE Token Distribution Event (TDE) happens The new airdrop is sent to the Flare addresses provided by XRP token holders when they claimed. Part of the airdrop is expected to go to Exchange accounts, which will then distribute it to the users that originally claimed (the intended recipients ). Flare will monitor how many of the airdrop tokens have reached the intended recipients, by following the Exchange's communication channels. FTSO data providers: Can now deploy their own validator nodes. The guide to do so will be available. Act as validators and their voting power depends on their FTSO performance and stake . FTSO and validator rewards are enabled. Inflation is not burned anymore.","title":"Initial Distribution Period"},{"location":"tech/flare-launch-process/#fip01-notice-period","text":"Trigger: 66% of the new airdrop reaches its intended recipients The FIP.01 proposal modifies how the rest of the tokens (after the TDE) are to be distributed, so it needs to be voted on by the community. Users will vote with their FLR token stake, so voting cannot start until enough tokens have reached the intended recipients. Once 66% of the FLR tokens distributed during the TDE reach these users, a 1-week notice period will start. Flare will announce to the community that enough tokens have been distributed and the notice period has started.","title":"FIP.01 Notice Period"},{"location":"tech/flare-launch-process/#fip01-voting-period","text":"Trigger: 1 week after Notice Period starts All FLR token holders (obtained either from the new airdrop or bought at Exchanges) can vote on FIP.01 using the voting frontend . Flare will announce to the community that the Voting Period has started and relay instructions on how to vote. Voting Period will last 1 week.","title":"FIP.01 Voting Period"},{"location":"tech/flare-launch-process/#regular-operation-beta","text":"Trigger: FIP.01 is approved after 1 week of voting The changes proposed in FIP.01 are implemented . The DIP is distributed to ALL holders of FLR during 37 months. Flare Beta is still in operation but community-run validators gradually gain more power.","title":"Regular Operation (Beta)"},{"location":"tech/flare-launch-process/#regular-operation","text":"Trigger: Community-run FTSO validators are deemed reliable enough Flare Beta ends. FTSO validators's validation power is not artificially reduced anymore and validator rewards (20% of inflation) are distributed equally among all validators according to their performance and stake.","title":"Regular Operation"},{"location":"tech/flare-launch-process/#regular-non-fip01-operation","text":"Trigger: FIP.01 is NOT approved after 1 week of voting The Original Distribution Plan is implemented.","title":"Regular Non-FIP.01 Operation"},{"location":"tech/ftso/","text":"FTSO # Introduction # The Flare Time Series Oracle (FTSO) is a smart contract running on the Flare network that provides continuous estimations for price pairs . It does so in a decentralized manner (no single party is in control of the process) and securely (it takes a lot of effort to disrupt the process). To achieve this, a set of independent data providers retrieves price pair information from external sources (like centralized and decentralized Exchanges) and supplies it to the FTSO system. This information is then weighted according to each provider's voting power and a median is calculated to produce the final estimate. FTSO summary. Data providers that supply useful information (price pairs that are not removed as outliers because they are too far away from the median value) are rewarded , and the resulting price estimates are finally published on-chain . This page gives technical details about the submission procedure, how the final estimate is calculated, how vote delegation works, how to submit price pairs, how to claim rewards and how to use the price information in an app. Procedure Overview # The following process runs continuously, producing new price estimates every Price Epoch , which are 3 minutes long . FTSO workflow. Any user with an account (address) on the Flare network can act as an FTSO data provider, submit price signals and collect rewards . Each epoch, only submissions from the 100 data providers with the most voting power are taken into account. An account's voting power is based on its wrapped $FLR or $SGB balance and the delegations made to it (see Vote Power below). Submitted data must be the current price (in $USD ) for one or more of the supported price pairs, currently: $XRP , $LTC , $XLM , $DOGE , $ADA , $ALGO , $BCH , $DGB , $BTC , $ETH , and $FIL . On Songbird, additionally, you have $SGB . More general data types might be added in the future. FTSO data providers submit price pairs in rounds in a Commit and Reveal fashion, so they cannot peek at each other's submissions until a round is over. This is akin to submitting prices in a closed envelope, so when the round is over all envelopes are opened. During a 3-minute price epoch, providers fetch the information, run their algorithms and submit a hash of the data ( commit ). During the first half of the following price epoch ( 1.5 minutes ) providers then submit the actual data ( reveal ). See technical details about the submission process below. The FTSO System calculates the resulting median price , taking into account each provider's voting power (see Resulting Price Calculation below). Resulting price pairs are publicly available for 5 price epochs for any app or contract to read. Previous epochs can always be retrieved from an archival node. For each price epoch in which the submitted data is close enough to the median price, data providers and their delegators are rewarded . Rewards are accumulated in Reward Epochs ( 3.5 days on the Flare network, 7 days on Songbird) and can be claimed once the epoch finishes. See Rewards below. Resulting Price Calculation # This is an overview of the filtering process that turns all submitted price pairs into a single estimate. See all details in the Flare whitepaper . FTSO price calculation. The contract in charge of each price pair calculates the resulting price for a Price Epoch (3 minutes) using the submissions received from all data providers during that epoch. Each submission has a price and a weight . Weight is based on the data provider's voting power , as explained below. The weighted median of the prices is the resulting price for the price epoch. Submissions in the top and bottom 25% range are not rewarded . Vote Power # FTSO delegation weight calculation. As explained above, an FTSO data provider's submissions are weighted by its Vote Power . A data provider's Vote Power is proportional to the amount of Wrapped Flare or Songbird tokens ( $WFLR or $WSGB ) it holds, plus any amount delegated to it . Note There also exists a Vote Power Cap which limits the influence of individual data providers to 2.5% of the total Vote Power on Flare, and 10% on Songbird. Any Vote Power above this cap is ignored, meaning that those $WFLR or $WSGB would probably be more effective delegated to a different data provider. A snapshot of each data provider's Vote Power is taken once per reward epoch, and the resulting weight is then used throughout the next reward epoch . The actual snapshot block is called the Voting Power Block and it is randomly chosen from the last blocks of the previous epoch (last 50% on Flare, last 25% on Songbird). Note this only roughly corresponds to last 50% or 25% of the time , since block production times are not constant. Reward epochs The first reward epoch on Songbird started on Saturday, 18 September 2021 08:41:39 (GMT), 1631954499 in Unix time, and repeats every 7 days. This means that all Songbird reward epochs start on Saturday morning (GMT) . The first reward epoch on Flare started on Thursday, 21 July 2022 19:00:05 (GMT), 1658430005 in Unix time, and repeats every 3.5 days. This means that all Flare reward epochs start on Thursday evening (GMT) and Monday morning (GMT) . Delegation # Holders of $FLR or $SGB tokens can delegate them to an FTSO data provider to increase its Vote Power and earn a share of its Rewards , resulting in a mutually beneficial arrangement . Furthermore, delegated tokens are not locked , meaning that they remain in the user's control and the delegation can be removed at any time. Delegation requires wrapping the native $FLR and $SGB into ERC-20 $WFLR and $WSGB tokens, a reversible operation that can also be undone at any time. Note Due to Vote Power being calculated once per reward epoch, new delegations do not take effect until the following reward epoch . Moreover, if a change in delegation occurs after the Vote Power Block is sampled (see above), its changes are delayed an extra reward epoch. Exception : Delegation revocation calls take effect immediately. Find more details in the Delegation guide . Delegation Procedure # The easiest way to delegate your tokens is through a supported wallet like Bifrost , or a dapp . Some FTSO data providers have already started providing these dapps as a convenience. Take a look at flaremetrics.io and pick the one you prefer. For advanced users, Manual Delegation and Claiming below briefly explains how to delegate manually by interacting directly with the FTSO smart contracts. Rewards # A percentage of the annual network inflation is reserved to reward FTSO data providers, and distributed uniformly among the year's reward epochs (reward epochs are 7-days long on Songbird and 3.5-days long on Flare). Each reward epoch, rewards are distributed among all data providers whose submission fell within 50% range of the calculated median price . Then, each provider takes a configurable fee (20% by default) and distributes the rest of the reward among all contributors to its Vote Power , i.e. itself and all its delegators, according to the delegated amounts. Find more details in the Delegation guide (Reward Claiming) . Reward Claiming Procedure # FTSO rewards are not automatically transferred to their recipients. Instead, the amounts are accumulated in the FtsoRewardManager contract (see System Architecture below) and must be claimed once the reward epoch is finished . Claiming requires a contract call and therefore a slight gas expenditure . To save on gas costs, multiple reward epochs can be claimed simultaneously, however, rewards expire after 90 days so be careful. Moreover, you probably want to claim soon, to re-delegate the received amount and obtain compounded rewards. It is also worth noting that: Rewards are paid in the network's native currency ( $FLR on Flare, $SGB on Songbird). Data providers and their delegators must claim independently. Again, the simplest way to claim your FTSO rewards is through a supported wallet like Bifrost , or a dapp. Take a look at flaremetrics.io and pick the one you prefer. For advanced users, Manual Delegation and Claiming below briefly explains how to claim manually by interacting directly with the FTSO smart contracts. Technical Details # This section is aimed at developers. System Architecture # The FTSO system is composed of multiple smart contracts running on the Flare Network. FTSO component smart contracts. These are the most relevant contracts and their purpose: FTSO : Each tracked price pair is handled by its own FTSO contract, including calculation of the filtered price feed. Access this contract to retrieve a specific price pair or information about it. Note If an FTSO contract is redeployed (for example, to fix a bug), its address will change and apps using it will need to be updated. The FTSO Registry contract below keeps track of this so you do not have to. You can retrieve the addresses of all FTSO contracts using the getAllFtsos method in the FTSO Registry (below). FTSO Registry : Aggregates the output of each individual FTSO contract and provides a convenient one-stop API to retrieve all price pairs. Price Submitter : This is the contract the FTSO data providers use to submit their data. Reward Manager : Use this contract to claim your rewards, whether you are a data provider or a delegator. Wrapped Native (WNat) : Not exclusively related to the FTSO system, but required to wrap and unwrap native tokens into the $WFLR and $WSGB that delegation requires. Note The Contract Addresses page explains how to retrieve each contract's address in a secure way. Other contracts (like the FTSO Manager or the FTSO Daemon) are only meant for internal use by the FTSO system. Manual Delegation and Claiming # This is a quick summary of the contracts and method calls required to manually delegate and claim FTSO rewards. Find more details in the Delegation guide . FTSO delegation process summary. Obtain wrapped tokens Voting power is delegated to a data provider using wrapped tokens ( WFLR and WSGB ) whereas the native tokens are FLR and SGB . One wrapped token can be obtained for each native token without cost (except gas fees) using the WNat contract's deposit method. Tokens get locked inside the WNat contract and cannot be used until they are unwrapped. Wrapped tokens can be unwrapped back to native tokens at any time using the WNat contract's withdraw method. Wrapped tokens adhere to the ERC-20 standard, besides deposit and withdraw : function deposit () public payable override ; function withdraw ( uint256 amount ) external override ; Delegate Choose the percentage of the total wrapped tokens you want to delegate to each data provider (up to two). Should the wrapped token balance change later, the delegated amounts are automatically adjusted. Delegation is performed through the WNat contract too, using the delegate method: function delegate ( address _to , uint256 _bips ) external ; You need to provide the address ( _to ) of the chosen data provider and the percentage ( _bips ) of the total wrapped amount you want to delegate in bips (hundredths of 1%, so 100% is 10\u2019000 bips). After a successful invocation of this method, delegation is complete . The following reward epoch will take the newly delegated tokens into account when computing your selected data provider's weight. If the data provider submits useful data and garners any rewards, you will be able to claim your share once the reward epoch is over . Claim rewards FTSO rewards are claimed using the claimReward method of the FtsoRewardManager contract: function claimReward ( address payable _recipient , uint256 [] memory _rewardEpochs ) external returns ( uint256 _rewardAmount ); This call must be made from the address that earned the rewards, but they can be sent to a different recipient, hence the _recipient parameter. Rewards can be claimed for several epochs at once so _rewardEpochs specifies the list of epochs to claim for. To get the list of epochs with pending rewards you can use the getEpochsWithUnclaimedRewards method. Moreover, the claimed reward is typically re-delegated, which involves wrapping the received $FLR or $SGB . For convenience, the claimAndWrapReward method is offered (only on Flare) to perform claiming and wrapping in a single call. Note For security reasons, the FtsoRewardManager contract contains a limited amount of tokens and is replenished periodically. If you are unable to claim your rewards because the contract is empty, please try again the next day . This might happen when all delegators claim their rewards in a short period of time, so it is usually better to avoid claiming right when the reward epoch finishes. Price Submission Process # Data submission uses a Commit and Reveal scheme to prevent providers from peeking at each other's submissions until a round is over. To speed up the process, both phases are actually overlapped so: All Commit phases happen continuously in so-called 3-minute Price Epochs . Reveal phases happen during the first half ( first 90 seconds ) of the following Commit phase. The published price information is therefore updated every 3 minutes . Only a hash of the data is submitted during the Commit phase. Next, in the Reveal phase the actual data is sent. If its hash does not match the previous commitment, the data is discarded. Submission API is slightly different for the Flare and Songbird networks: Flare Songbird FTSO data providers submit price information through the PriceSubmitter contract . Commit : A single hash is needed for all price pairs. function submitHash ( uint256 _epochId , bytes32 _hash ) external ; Reveal : After all price data, a single random number must be submitted. function revealPrices ( uint256 _epochId , uint256 [] memory _ftsoIndices , uint256 [] memory _prices , uint256 _random ) external ; FTSO data providers submit price information through the PriceSubmitter contract . Commit : A separate hash is needed for each price pair. function submitPriceHashes ( uint256 _epochId , uint256 [] memory _ftsoIndices , bytes32 [] memory _hashes ) external ; Reveal : Along with each price a random number must be submitted. function revealPrices ( uint256 _epochId , uint256 [] memory _ftsoIndices , uint256 [] memory _prices , uint256 [] memory _randoms ) external ; Using the Price Pairs # The price pairs produced by the FTSO are publicly available on the Flare and Songbird networks. All pairs can be retrieved either through the FtsoRegistry contract or directly through one of the Ftso contracts that handle each individual price pair. In any case, the getCurrentPrice method is used: Retrieve by pair index Retrieve by pair symbol Retrieve directly From the FtsoRegistry contract: function getCurrentPrice ( uint256 _ftsoIndex ) external view returns ( uint256 _price , uint256 _timestamp ); Where _ftsoIndex is one of the allowed indices returned by getSupportedIndices , for example. From the FtsoRegistry contract: function getCurrentPrice ( string memory _symbol ) external view returns ( uint256 _price , uint256 _timestamp ); Where _symbol is one of the allowed symbols returned by getSupportedSymbols , for example. First you need to obtain the address of the Ftso contract managing the price pair you are interested in. You can use getSupportedIndicesSymbolsAndFtsos from the FtsoRegistry , for example. Then call getCurrentPrice on the FTSO directly: function getCurrentPrice ( ) external view returns ( uint256 _price , uint256 _timestamp ); Note Individual FTSO contracts might be updated from time to time, changing their address. It is advisable not to cache these addresses and always use the FtsoRegistry instead. GetCurrentPrice returns the requested price (the outcome of the previous 3-minute price epoch) in $USD multiplied by 100'000 . So, for instance, a return value of 2603 means a price of 0.02603 USD (There are only 5 significant decimal places). A standard Unix timestamp of the last price update is also returned.","title":"FTSO"},{"location":"tech/ftso/#ftso","text":"","title":"FTSO"},{"location":"tech/ftso/#introduction","text":"The Flare Time Series Oracle (FTSO) is a smart contract running on the Flare network that provides continuous estimations for price pairs . It does so in a decentralized manner (no single party is in control of the process) and securely (it takes a lot of effort to disrupt the process). To achieve this, a set of independent data providers retrieves price pair information from external sources (like centralized and decentralized Exchanges) and supplies it to the FTSO system. This information is then weighted according to each provider's voting power and a median is calculated to produce the final estimate. FTSO summary. Data providers that supply useful information (price pairs that are not removed as outliers because they are too far away from the median value) are rewarded , and the resulting price estimates are finally published on-chain . This page gives technical details about the submission procedure, how the final estimate is calculated, how vote delegation works, how to submit price pairs, how to claim rewards and how to use the price information in an app.","title":"Introduction"},{"location":"tech/ftso/#procedure-overview","text":"The following process runs continuously, producing new price estimates every Price Epoch , which are 3 minutes long . FTSO workflow. Any user with an account (address) on the Flare network can act as an FTSO data provider, submit price signals and collect rewards . Each epoch, only submissions from the 100 data providers with the most voting power are taken into account. An account's voting power is based on its wrapped $FLR or $SGB balance and the delegations made to it (see Vote Power below). Submitted data must be the current price (in $USD ) for one or more of the supported price pairs, currently: $XRP , $LTC , $XLM , $DOGE , $ADA , $ALGO , $BCH , $DGB , $BTC , $ETH , and $FIL . On Songbird, additionally, you have $SGB . More general data types might be added in the future. FTSO data providers submit price pairs in rounds in a Commit and Reveal fashion, so they cannot peek at each other's submissions until a round is over. This is akin to submitting prices in a closed envelope, so when the round is over all envelopes are opened. During a 3-minute price epoch, providers fetch the information, run their algorithms and submit a hash of the data ( commit ). During the first half of the following price epoch ( 1.5 minutes ) providers then submit the actual data ( reveal ). See technical details about the submission process below. The FTSO System calculates the resulting median price , taking into account each provider's voting power (see Resulting Price Calculation below). Resulting price pairs are publicly available for 5 price epochs for any app or contract to read. Previous epochs can always be retrieved from an archival node. For each price epoch in which the submitted data is close enough to the median price, data providers and their delegators are rewarded . Rewards are accumulated in Reward Epochs ( 3.5 days on the Flare network, 7 days on Songbird) and can be claimed once the epoch finishes. See Rewards below.","title":"Procedure Overview"},{"location":"tech/ftso/#resulting-price-calculation","text":"This is an overview of the filtering process that turns all submitted price pairs into a single estimate. See all details in the Flare whitepaper . FTSO price calculation. The contract in charge of each price pair calculates the resulting price for a Price Epoch (3 minutes) using the submissions received from all data providers during that epoch. Each submission has a price and a weight . Weight is based on the data provider's voting power , as explained below. The weighted median of the prices is the resulting price for the price epoch. Submissions in the top and bottom 25% range are not rewarded .","title":"Resulting Price Calculation"},{"location":"tech/ftso/#vote-power","text":"FTSO delegation weight calculation. As explained above, an FTSO data provider's submissions are weighted by its Vote Power . A data provider's Vote Power is proportional to the amount of Wrapped Flare or Songbird tokens ( $WFLR or $WSGB ) it holds, plus any amount delegated to it . Note There also exists a Vote Power Cap which limits the influence of individual data providers to 2.5% of the total Vote Power on Flare, and 10% on Songbird. Any Vote Power above this cap is ignored, meaning that those $WFLR or $WSGB would probably be more effective delegated to a different data provider. A snapshot of each data provider's Vote Power is taken once per reward epoch, and the resulting weight is then used throughout the next reward epoch . The actual snapshot block is called the Voting Power Block and it is randomly chosen from the last blocks of the previous epoch (last 50% on Flare, last 25% on Songbird). Note this only roughly corresponds to last 50% or 25% of the time , since block production times are not constant. Reward epochs The first reward epoch on Songbird started on Saturday, 18 September 2021 08:41:39 (GMT), 1631954499 in Unix time, and repeats every 7 days. This means that all Songbird reward epochs start on Saturday morning (GMT) . The first reward epoch on Flare started on Thursday, 21 July 2022 19:00:05 (GMT), 1658430005 in Unix time, and repeats every 3.5 days. This means that all Flare reward epochs start on Thursday evening (GMT) and Monday morning (GMT) .","title":"Vote Power"},{"location":"tech/ftso/#delegation","text":"Holders of $FLR or $SGB tokens can delegate them to an FTSO data provider to increase its Vote Power and earn a share of its Rewards , resulting in a mutually beneficial arrangement . Furthermore, delegated tokens are not locked , meaning that they remain in the user's control and the delegation can be removed at any time. Delegation requires wrapping the native $FLR and $SGB into ERC-20 $WFLR and $WSGB tokens, a reversible operation that can also be undone at any time. Note Due to Vote Power being calculated once per reward epoch, new delegations do not take effect until the following reward epoch . Moreover, if a change in delegation occurs after the Vote Power Block is sampled (see above), its changes are delayed an extra reward epoch. Exception : Delegation revocation calls take effect immediately. Find more details in the Delegation guide .","title":"Delegation"},{"location":"tech/ftso/#delegation-procedure","text":"The easiest way to delegate your tokens is through a supported wallet like Bifrost , or a dapp . Some FTSO data providers have already started providing these dapps as a convenience. Take a look at flaremetrics.io and pick the one you prefer. For advanced users, Manual Delegation and Claiming below briefly explains how to delegate manually by interacting directly with the FTSO smart contracts.","title":"Delegation Procedure"},{"location":"tech/ftso/#rewards","text":"A percentage of the annual network inflation is reserved to reward FTSO data providers, and distributed uniformly among the year's reward epochs (reward epochs are 7-days long on Songbird and 3.5-days long on Flare). Each reward epoch, rewards are distributed among all data providers whose submission fell within 50% range of the calculated median price . Then, each provider takes a configurable fee (20% by default) and distributes the rest of the reward among all contributors to its Vote Power , i.e. itself and all its delegators, according to the delegated amounts. Find more details in the Delegation guide (Reward Claiming) .","title":"Rewards"},{"location":"tech/ftso/#reward-claiming-procedure","text":"FTSO rewards are not automatically transferred to their recipients. Instead, the amounts are accumulated in the FtsoRewardManager contract (see System Architecture below) and must be claimed once the reward epoch is finished . Claiming requires a contract call and therefore a slight gas expenditure . To save on gas costs, multiple reward epochs can be claimed simultaneously, however, rewards expire after 90 days so be careful. Moreover, you probably want to claim soon, to re-delegate the received amount and obtain compounded rewards. It is also worth noting that: Rewards are paid in the network's native currency ( $FLR on Flare, $SGB on Songbird). Data providers and their delegators must claim independently. Again, the simplest way to claim your FTSO rewards is through a supported wallet like Bifrost , or a dapp. Take a look at flaremetrics.io and pick the one you prefer. For advanced users, Manual Delegation and Claiming below briefly explains how to claim manually by interacting directly with the FTSO smart contracts.","title":"Reward Claiming Procedure"},{"location":"tech/ftso/#technical-details","text":"This section is aimed at developers.","title":"Technical Details"},{"location":"tech/ftso/#system-architecture","text":"The FTSO system is composed of multiple smart contracts running on the Flare Network. FTSO component smart contracts. These are the most relevant contracts and their purpose: FTSO : Each tracked price pair is handled by its own FTSO contract, including calculation of the filtered price feed. Access this contract to retrieve a specific price pair or information about it. Note If an FTSO contract is redeployed (for example, to fix a bug), its address will change and apps using it will need to be updated. The FTSO Registry contract below keeps track of this so you do not have to. You can retrieve the addresses of all FTSO contracts using the getAllFtsos method in the FTSO Registry (below). FTSO Registry : Aggregates the output of each individual FTSO contract and provides a convenient one-stop API to retrieve all price pairs. Price Submitter : This is the contract the FTSO data providers use to submit their data. Reward Manager : Use this contract to claim your rewards, whether you are a data provider or a delegator. Wrapped Native (WNat) : Not exclusively related to the FTSO system, but required to wrap and unwrap native tokens into the $WFLR and $WSGB that delegation requires. Note The Contract Addresses page explains how to retrieve each contract's address in a secure way. Other contracts (like the FTSO Manager or the FTSO Daemon) are only meant for internal use by the FTSO system.","title":"System Architecture"},{"location":"tech/ftso/#manual-delegation-and-claiming","text":"This is a quick summary of the contracts and method calls required to manually delegate and claim FTSO rewards. Find more details in the Delegation guide . FTSO delegation process summary. Obtain wrapped tokens Voting power is delegated to a data provider using wrapped tokens ( WFLR and WSGB ) whereas the native tokens are FLR and SGB . One wrapped token can be obtained for each native token without cost (except gas fees) using the WNat contract's deposit method. Tokens get locked inside the WNat contract and cannot be used until they are unwrapped. Wrapped tokens can be unwrapped back to native tokens at any time using the WNat contract's withdraw method. Wrapped tokens adhere to the ERC-20 standard, besides deposit and withdraw : function deposit () public payable override ; function withdraw ( uint256 amount ) external override ; Delegate Choose the percentage of the total wrapped tokens you want to delegate to each data provider (up to two). Should the wrapped token balance change later, the delegated amounts are automatically adjusted. Delegation is performed through the WNat contract too, using the delegate method: function delegate ( address _to , uint256 _bips ) external ; You need to provide the address ( _to ) of the chosen data provider and the percentage ( _bips ) of the total wrapped amount you want to delegate in bips (hundredths of 1%, so 100% is 10\u2019000 bips). After a successful invocation of this method, delegation is complete . The following reward epoch will take the newly delegated tokens into account when computing your selected data provider's weight. If the data provider submits useful data and garners any rewards, you will be able to claim your share once the reward epoch is over . Claim rewards FTSO rewards are claimed using the claimReward method of the FtsoRewardManager contract: function claimReward ( address payable _recipient , uint256 [] memory _rewardEpochs ) external returns ( uint256 _rewardAmount ); This call must be made from the address that earned the rewards, but they can be sent to a different recipient, hence the _recipient parameter. Rewards can be claimed for several epochs at once so _rewardEpochs specifies the list of epochs to claim for. To get the list of epochs with pending rewards you can use the getEpochsWithUnclaimedRewards method. Moreover, the claimed reward is typically re-delegated, which involves wrapping the received $FLR or $SGB . For convenience, the claimAndWrapReward method is offered (only on Flare) to perform claiming and wrapping in a single call. Note For security reasons, the FtsoRewardManager contract contains a limited amount of tokens and is replenished periodically. If you are unable to claim your rewards because the contract is empty, please try again the next day . This might happen when all delegators claim their rewards in a short period of time, so it is usually better to avoid claiming right when the reward epoch finishes.","title":"Manual Delegation and Claiming"},{"location":"tech/ftso/#price-submission-process","text":"Data submission uses a Commit and Reveal scheme to prevent providers from peeking at each other's submissions until a round is over. To speed up the process, both phases are actually overlapped so: All Commit phases happen continuously in so-called 3-minute Price Epochs . Reveal phases happen during the first half ( first 90 seconds ) of the following Commit phase. The published price information is therefore updated every 3 minutes . Only a hash of the data is submitted during the Commit phase. Next, in the Reveal phase the actual data is sent. If its hash does not match the previous commitment, the data is discarded. Submission API is slightly different for the Flare and Songbird networks: Flare Songbird FTSO data providers submit price information through the PriceSubmitter contract . Commit : A single hash is needed for all price pairs. function submitHash ( uint256 _epochId , bytes32 _hash ) external ; Reveal : After all price data, a single random number must be submitted. function revealPrices ( uint256 _epochId , uint256 [] memory _ftsoIndices , uint256 [] memory _prices , uint256 _random ) external ; FTSO data providers submit price information through the PriceSubmitter contract . Commit : A separate hash is needed for each price pair. function submitPriceHashes ( uint256 _epochId , uint256 [] memory _ftsoIndices , bytes32 [] memory _hashes ) external ; Reveal : Along with each price a random number must be submitted. function revealPrices ( uint256 _epochId , uint256 [] memory _ftsoIndices , uint256 [] memory _prices , uint256 [] memory _randoms ) external ;","title":"Price Submission Process"},{"location":"tech/ftso/#using-the-price-pairs","text":"The price pairs produced by the FTSO are publicly available on the Flare and Songbird networks. All pairs can be retrieved either through the FtsoRegistry contract or directly through one of the Ftso contracts that handle each individual price pair. In any case, the getCurrentPrice method is used: Retrieve by pair index Retrieve by pair symbol Retrieve directly From the FtsoRegistry contract: function getCurrentPrice ( uint256 _ftsoIndex ) external view returns ( uint256 _price , uint256 _timestamp ); Where _ftsoIndex is one of the allowed indices returned by getSupportedIndices , for example. From the FtsoRegistry contract: function getCurrentPrice ( string memory _symbol ) external view returns ( uint256 _price , uint256 _timestamp ); Where _symbol is one of the allowed symbols returned by getSupportedSymbols , for example. First you need to obtain the address of the Ftso contract managing the price pair you are interested in. You can use getSupportedIndicesSymbolsAndFtsos from the FtsoRegistry , for example. Then call getCurrentPrice on the FTSO directly: function getCurrentPrice ( ) external view returns ( uint256 _price , uint256 _timestamp ); Note Individual FTSO contracts might be updated from time to time, changing their address. It is advisable not to cache these addresses and always use the FtsoRegistry instead. GetCurrentPrice returns the requested price (the outcome of the previous 3-minute price epoch) in $USD multiplied by 100'000 . So, for instance, a return value of 2603 means a price of 0.02603 USD (There are only 5 significant decimal places). A standard Unix timestamp of the last price update is also returned.","title":"Using the Price Pairs"},{"location":"tech/glossary/","text":"Glossary # Attestation A data proof provided to the State Connector by a decentralized set of Attestation Providers that confirms the validity or otherwise of any request. Avalanche An open-source blockchain using the Snow family of consensus protocols and Proof of Stake for Sybil resistance . It is advertised as the fastest smart contract platform. Read more... Block For performance reasons, blockchains do not process transactions one by one. Instead, transactions are grouped together in blocks which are then validated by the consensus algorithm. Blockchain Digital ledger storing data and transactions on a distributed network of computers to make it more robust. Cryptography protects against information tampering, and a consensus algorithm ensures that the majority of the network agrees on the stored data even if some of its nodes act maliciously. Byzantine Fault Tolerance Property of a distributed system that is capable of continuous operation even when some of its participants are unreliable. Participants acting against the interest of the whole system, by accident or on purpose, are said to have \u201cgone Byzantine\u201d. Canary Network A network used for testing features under \u201creal fire\u201d conditions, before deploying them on the main network . All users of the canary network are real users, but they are aware of the experimental nature of the platform. The name comes from the time when actual miners used actual canaries to detect the presence of poisonous gas in the mines. Flare's canary network is called Songbird . Consensus Algorithm that makes nodes on a blockchain\u2019s network agree on the validity of a given transaction, even if some of the nodes provide invalid transactions or try to disrupt the network ( Byzantine Fault Tolerance ). Coston The name given to Flare's public test networks , in remembrance and celebration of a great inventor, Martha J. Coston (1826-1904). Cross-chain (or inter-ecosystem) interoperability Communication between two or more disparate blockchain ecosystems that are technologically incompatible due to the lack of shared systems, protocols or code (e.g. Ethereum and Solana). DAO A Decentralized Autonomous Organization is an entity with no central authority. Its governance is mandated by rules encoded on a blockchain so it is tamper-proof. dApp A Decentralized Application is a computer program that makes use of blockchain technology and therefore the information it uses or stores has the same benefits (trustlessness, censorship resistance, geographical redundancy, etc). The dapp itself may or may not be hosted on a blockchain. Data Provider Each of the multiple programs supplying external information to an FTSO running on the Flare network, and getting rewarded for it. Token holders can delegate their stake to a data provider and receive a share of the rewards. DeFi Decentralized Finance is a form of finance that does not rely on a central financial institution. DeFi is commonly based on blockchain technology. Delegate To assign a duty to someone else, so they do it for you. On the Flare network, an address can delegate any fraction of the votes associated with the tokens it holds to another address, for the purpose of FTSO weighting or governance participation. Note that no tokens are transferred. EVM The Ethereum Virtual Machine allows executing smart contracts on the Ethereum network, regardless of the kind of computer that executes it. Multiple blockchain networks, including Flare, support EVM contracts. Read more... Faucet A dapp that distributes test tokens to anyone that requests them. Used only on test networks , obviously. See the Network Configurations page to learn about Flare's faucets. FBA Federated Byzantine Agreement is a form of Byzantine fault tolerance where each node keeps its own list of trusted nodes. It does not require nodes to invest stake or computing power as Proof of Stake or Proof of Work protocols do. FCP The Flare Consensus Protocol is an asynchronous, ordered and leaderless version of Federated Byzantine Agreement ( FBA ) consensus. The whitepaper is already available and it is currently in the process of being implemented. Read more... Flare Token (FLR) The native currency of the Flare's main network . FTSO The Flare Time Series Oracles provide external information to the Flare network in a decentralized manner, by using multiple independent data providers that are rewarded for providing accurate information. Read more... Governance Mechanism to propose, vote and implement changes on a blockchain protocol. On Flare, anybody can propose updates and token holders vote to accept them. Ledger Historically, a book where financial transactions are recorded. In blockchain technology a ledger can contain any kind of information and it has multiple copies distributed among several computers, which are kept in sync by a consensus algorithm. Light Client Relay A simplified communication mechanism built for speed that only queries the header data of any transaction and therefore lacks the security that comes from querying a full node with full history (e.g. SPV ). Liquidity Pool A collection of funds locked in a smart contract for the purpose of facilitating trading, lending and other functionality in a decentralized manner. Main Network (MAINNET) The computer network that supports a blockchain in its production stage, i.e., the real thing (instead of a Canary or Test network). Metaverse An old concept, at times called Virtual Reality or Cyberspace, that translates human interaction to virtual (i.e. non-physical) worlds. Currently in vogue again because blockchain technology promises to link the physical and the virtual worlds and thus bring a degree of reality to the latter. Multi-chain (or intra-ecosystem) interoperability Communication between two or more technologically compatible blockchains that exist within the same ecosystem and share systems, protocols and code (e.g. Polkadot Parachains , Cosmos Tendermint chains or Ethereum layer 2 protocols). NFT Non-Fungible Tokens are digital representations of assets which are unique and therefore non-mergeable (non-fungible), made impossible to copy by blockchain technology. Common use cases are certificates of authenticity or ownership, or limited edition collectibles. Most NFT tokens are built on the Ethereum network using standards ERC-721 and ERC-1155 . Oracle A mechanism to provide external information to a blockchain, so that it can be used by smart contracts , for example. Flare oracles are called FTSO . Proof of Stake A kind of Sybil resistance based on staking assets to participate in consensus. The rationale is that a participant investing enough assets will not be interested in attacking the network that supports such assets. Moreover, if malicious behavior is detected part of the assets can be taken as punishment. Proof of Work A kind of Sybil resistance based on spending computer power to participate in consensus. The rationale is that attacking the network becomes prohibitively expensive in terms of computer power. Pruning A blockchain database reduction technique, which keeps the state of all addresses (like their balance) and the transactions that led to that state, but removes any old transaction that does not impact the current state anymore. Quantum Resistance The ability of a cryptographic algorithm (and therefore of a blockchain) to resist an attack from a theoretical quantum computer. Quorum Set of participants on a consensus algorithm that must agree on a result for the whole network to accept that result. On a blockchain, once consensus is reached about a block , it is added to the ledger and the next block is processed. Quorum Slice In FBA consensus each node has multiple lists of other nodes which it voluntarily decides to trust, forming its quorum slices. All nodes in a quorum slice agreeing on a result are enough to convince the node of that result. If the quorum slices are correctly built, global quorum emerges from these local quorum slices. RPC Remote Procedure Call is a protocol that allows a program executing on a computer to request a service from another program, typically running on a different computer. Smart Contract Computer program running on a blockchain, typically one based on the EVM . The blockchain\u2019s immutability ensures that the contract is not tampered with, and running it on several machines bound together by a consensus algorithm ensures faithful execution. Smart contracts are said to be self-enforcing. Songbird Flare's canary network , launched in September 2021. State Connector Piece of the Flare network that keeps track of the state of other networks, facilitating the implementation of advanced mechanisms like the FAssets. The State Connector uses several independent Attestation Providers that are rewarded for providing correct information. Read more... Sybil Resistance The ability of a distributed system to overcome a Sybil attack, in which a malicious actor creates multiple identities to gain voting or mining power. Resistance is typically gained by making voting or mining too costly for the attack to be worth it (as in Proof of Work or Proof of Stake ) or by requiring new entities to be approved by existing actors (as in FBA ). Test Network (TESTNET) The computer network that supports a blockchain in its development stage. It is intended for testing purposes and should not store valuable assets, as its contents might be deleted (purposely or by accident) at any time. Among other facilities, testnets typically provide faucets . Compare to a Canary or Main network. Flare's testnet is called Coston . Transaction A request to add information to the blockchain, which is then analyzed by the network and accepted when consensus is reached about its validity. It can be a movement of funds between two accounts, or the execution of a contract, for example. Transaction Fee Amount of cryptocurrency that must be paid by anybody submitting a transaction for inclusion on a blockchain. These fees reward block producers for their work processing transactions, and typically vary depending on network congestion. Token A digital representation of an asset. Fungible tokens are indistinguishable from one another so they can be merged together (e.g. a cryptocurrency). Non-fungible tokens ( NFT ) are unique and therefore cannot be merged. Turing-completeness The ability of a machine to solve any computational problem, no matter how complex, given the necessary steps and enough time and memory. This is a mandatory feature of any general-purpose processor like a CPU or the EVM . Validator A validator node is a machine connected to a blockchain network that verifies transactions and emits a vote. When there is a quorum among all validators regarding a given block of transactions, they are accepted into the blockchain. Voting Power Weight proportional to the tokens held by an address plus the tokens delegated to it. This weight is used during FTSO operation and governance votes, for example. Wen flare The war cry of all the impatient that would like to see the Flare network launch before it is fully tested. Pay no heed to them. /*Glossary links from within the glossary page*/ a[href^=\"#\"] { text-decoration-style: dotted; text-decoration-thickness: 1px; } /*Separating line for the glossary nav link from within the glossary page*/ .md-nav__link.md-nav__link--active { border-top: solid 1px var(--md-default-fg-color--lightest); padding-top: 8px; }","title":"Glossary"},{"location":"tech/glossary/#glossary","text":"Attestation A data proof provided to the State Connector by a decentralized set of Attestation Providers that confirms the validity or otherwise of any request. Avalanche An open-source blockchain using the Snow family of consensus protocols and Proof of Stake for Sybil resistance . It is advertised as the fastest smart contract platform. Read more... Block For performance reasons, blockchains do not process transactions one by one. Instead, transactions are grouped together in blocks which are then validated by the consensus algorithm. Blockchain Digital ledger storing data and transactions on a distributed network of computers to make it more robust. Cryptography protects against information tampering, and a consensus algorithm ensures that the majority of the network agrees on the stored data even if some of its nodes act maliciously. Byzantine Fault Tolerance Property of a distributed system that is capable of continuous operation even when some of its participants are unreliable. Participants acting against the interest of the whole system, by accident or on purpose, are said to have \u201cgone Byzantine\u201d. Canary Network A network used for testing features under \u201creal fire\u201d conditions, before deploying them on the main network . All users of the canary network are real users, but they are aware of the experimental nature of the platform. The name comes from the time when actual miners used actual canaries to detect the presence of poisonous gas in the mines. Flare's canary network is called Songbird . Consensus Algorithm that makes nodes on a blockchain\u2019s network agree on the validity of a given transaction, even if some of the nodes provide invalid transactions or try to disrupt the network ( Byzantine Fault Tolerance ). Coston The name given to Flare's public test networks , in remembrance and celebration of a great inventor, Martha J. Coston (1826-1904). Cross-chain (or inter-ecosystem) interoperability Communication between two or more disparate blockchain ecosystems that are technologically incompatible due to the lack of shared systems, protocols or code (e.g. Ethereum and Solana). DAO A Decentralized Autonomous Organization is an entity with no central authority. Its governance is mandated by rules encoded on a blockchain so it is tamper-proof. dApp A Decentralized Application is a computer program that makes use of blockchain technology and therefore the information it uses or stores has the same benefits (trustlessness, censorship resistance, geographical redundancy, etc). The dapp itself may or may not be hosted on a blockchain. Data Provider Each of the multiple programs supplying external information to an FTSO running on the Flare network, and getting rewarded for it. Token holders can delegate their stake to a data provider and receive a share of the rewards. DeFi Decentralized Finance is a form of finance that does not rely on a central financial institution. DeFi is commonly based on blockchain technology. Delegate To assign a duty to someone else, so they do it for you. On the Flare network, an address can delegate any fraction of the votes associated with the tokens it holds to another address, for the purpose of FTSO weighting or governance participation. Note that no tokens are transferred. EVM The Ethereum Virtual Machine allows executing smart contracts on the Ethereum network, regardless of the kind of computer that executes it. Multiple blockchain networks, including Flare, support EVM contracts. Read more... Faucet A dapp that distributes test tokens to anyone that requests them. Used only on test networks , obviously. See the Network Configurations page to learn about Flare's faucets. FBA Federated Byzantine Agreement is a form of Byzantine fault tolerance where each node keeps its own list of trusted nodes. It does not require nodes to invest stake or computing power as Proof of Stake or Proof of Work protocols do. FCP The Flare Consensus Protocol is an asynchronous, ordered and leaderless version of Federated Byzantine Agreement ( FBA ) consensus. The whitepaper is already available and it is currently in the process of being implemented. Read more... Flare Token (FLR) The native currency of the Flare's main network . FTSO The Flare Time Series Oracles provide external information to the Flare network in a decentralized manner, by using multiple independent data providers that are rewarded for providing accurate information. Read more... Governance Mechanism to propose, vote and implement changes on a blockchain protocol. On Flare, anybody can propose updates and token holders vote to accept them. Ledger Historically, a book where financial transactions are recorded. In blockchain technology a ledger can contain any kind of information and it has multiple copies distributed among several computers, which are kept in sync by a consensus algorithm. Light Client Relay A simplified communication mechanism built for speed that only queries the header data of any transaction and therefore lacks the security that comes from querying a full node with full history (e.g. SPV ). Liquidity Pool A collection of funds locked in a smart contract for the purpose of facilitating trading, lending and other functionality in a decentralized manner. Main Network (MAINNET) The computer network that supports a blockchain in its production stage, i.e., the real thing (instead of a Canary or Test network). Metaverse An old concept, at times called Virtual Reality or Cyberspace, that translates human interaction to virtual (i.e. non-physical) worlds. Currently in vogue again because blockchain technology promises to link the physical and the virtual worlds and thus bring a degree of reality to the latter. Multi-chain (or intra-ecosystem) interoperability Communication between two or more technologically compatible blockchains that exist within the same ecosystem and share systems, protocols and code (e.g. Polkadot Parachains , Cosmos Tendermint chains or Ethereum layer 2 protocols). NFT Non-Fungible Tokens are digital representations of assets which are unique and therefore non-mergeable (non-fungible), made impossible to copy by blockchain technology. Common use cases are certificates of authenticity or ownership, or limited edition collectibles. Most NFT tokens are built on the Ethereum network using standards ERC-721 and ERC-1155 . Oracle A mechanism to provide external information to a blockchain, so that it can be used by smart contracts , for example. Flare oracles are called FTSO . Proof of Stake A kind of Sybil resistance based on staking assets to participate in consensus. The rationale is that a participant investing enough assets will not be interested in attacking the network that supports such assets. Moreover, if malicious behavior is detected part of the assets can be taken as punishment. Proof of Work A kind of Sybil resistance based on spending computer power to participate in consensus. The rationale is that attacking the network becomes prohibitively expensive in terms of computer power. Pruning A blockchain database reduction technique, which keeps the state of all addresses (like their balance) and the transactions that led to that state, but removes any old transaction that does not impact the current state anymore. Quantum Resistance The ability of a cryptographic algorithm (and therefore of a blockchain) to resist an attack from a theoretical quantum computer. Quorum Set of participants on a consensus algorithm that must agree on a result for the whole network to accept that result. On a blockchain, once consensus is reached about a block , it is added to the ledger and the next block is processed. Quorum Slice In FBA consensus each node has multiple lists of other nodes which it voluntarily decides to trust, forming its quorum slices. All nodes in a quorum slice agreeing on a result are enough to convince the node of that result. If the quorum slices are correctly built, global quorum emerges from these local quorum slices. RPC Remote Procedure Call is a protocol that allows a program executing on a computer to request a service from another program, typically running on a different computer. Smart Contract Computer program running on a blockchain, typically one based on the EVM . The blockchain\u2019s immutability ensures that the contract is not tampered with, and running it on several machines bound together by a consensus algorithm ensures faithful execution. Smart contracts are said to be self-enforcing. Songbird Flare's canary network , launched in September 2021. State Connector Piece of the Flare network that keeps track of the state of other networks, facilitating the implementation of advanced mechanisms like the FAssets. The State Connector uses several independent Attestation Providers that are rewarded for providing correct information. Read more... Sybil Resistance The ability of a distributed system to overcome a Sybil attack, in which a malicious actor creates multiple identities to gain voting or mining power. Resistance is typically gained by making voting or mining too costly for the attack to be worth it (as in Proof of Work or Proof of Stake ) or by requiring new entities to be approved by existing actors (as in FBA ). Test Network (TESTNET) The computer network that supports a blockchain in its development stage. It is intended for testing purposes and should not store valuable assets, as its contents might be deleted (purposely or by accident) at any time. Among other facilities, testnets typically provide faucets . Compare to a Canary or Main network. Flare's testnet is called Coston . Transaction A request to add information to the blockchain, which is then analyzed by the network and accepted when consensus is reached about its validity. It can be a movement of funds between two accounts, or the execution of a contract, for example. Transaction Fee Amount of cryptocurrency that must be paid by anybody submitting a transaction for inclusion on a blockchain. These fees reward block producers for their work processing transactions, and typically vary depending on network congestion. Token A digital representation of an asset. Fungible tokens are indistinguishable from one another so they can be merged together (e.g. a cryptocurrency). Non-fungible tokens ( NFT ) are unique and therefore cannot be merged. Turing-completeness The ability of a machine to solve any computational problem, no matter how complex, given the necessary steps and enough time and memory. This is a mandatory feature of any general-purpose processor like a CPU or the EVM . Validator A validator node is a machine connected to a blockchain network that verifies transactions and emits a vote. When there is a quorum among all validators regarding a given block of transactions, they are accepted into the blockchain. Voting Power Weight proportional to the tokens held by an address plus the tokens delegated to it. This weight is used during FTSO operation and governance votes, for example. Wen flare The war cry of all the impatient that would like to see the Flare network launch before it is fully tested. Pay no heed to them. /*Glossary links from within the glossary page*/ a[href^=\"#\"] { text-decoration-style: dotted; text-decoration-thickness: 1px; } /*Separating line for the glossary nav link from within the glossary page*/ .md-nav__link.md-nav__link--active { border-top: solid 1px var(--md-default-fg-color--lightest); padding-top: 8px; }","title":"Glossary"},{"location":"tech/state-connector/","text":"State Connector # Introduction # The State Connector is a smart contract running on the Flare network that allows anyone to query information from outside the Flare network . It does so in a decentralized manner (no single party is in control of the process) and securely (it takes a lot of effort to disrupt the process). This is accomplished by using a set of independent attestation providers which fetch the required information from the world and deliver it to the Flare network. The State Connector smart contract then checks if there is enough consensus among the received answers and publishes the results if so. As an added security measure, individual validators can also define local attestation providers which, when in disagreement with the rest, cause the validator to branch into an idle, safe state while the situation is resolved. The State Connector. The State Connector can, for instance, check whether a deposit has been made on another blockchain , opening the door to more advanced mechanisms like the FAsset or the LayerCake bridges. This page gives technical details about the whole procedure, the different security and scalability measures that have been taken into account in its design and the kind of queries that can be performed. Procedure Overview # This is how user queries are processed. The following sections contain more details. State Connector procedure overview. 1. Request # Anybody, be it a smart contract running on Flare or an application, can request the attestation of a specific event from the State Connector. Requests are yes/no questions regarding things that happened outside the Flare network, for example, \"Has transaction 0xABC been confirmed on the Bitcoin network enough times?\". The answers, though, might contain any kind of additional data attached, like the content of transaction 0xABC, for example. Requests must adhere to one of the available request types , which have been designed to be strictly decidable , i.e., the answers are objective and cannot be argued. Otherwise, queries like \"What is the weather like in Paris?\" would have a hard time reaching consensus among the different attestation providers. Section Adding New Attestation Types below contains more details. Making a request (for App developers) Make your requests using the requestAttestations method (#2) of the StateConnector contract : function requestAttestations ( bytes calldata data ) external ; The requestAttestations method has a single parameter, data , which is a byte array with a content that depends on the desired request type . You can learn how to build this array in the state-connector-attestation-types repository . 2. Request forwarding # The State Connector simply forwards the request to all connected attestation providers through an EVM event. Therefore, the request is not stored on the blockchain and its gas cost is very low for the requester. 3. Data retrieval # Attestation providers fetch the requested data by means that depend on the type of attestation. E.g., retrieving data from another blockchain or public API. Keep in mind that attestation providers are not controlled by Flare in any way. Anybody can listen to the request events and provide answers using any combination of hardware, software and code they see fit. 4. Attestation # To prevent attestation providers from peeking at each other's answers, these are submitted in a \"Commit and Reveal\" fashion called the RCR protocol and detailed below. Submitting an attestation (For attestation provider developers) Attestation providers use the submitAttestation method (#3) of the StateConnector contract : function submitAttestation ( uint256 _bufferNumber , bytes32 _commitHash , bytes32 _merkleRoot , bytes32 _randomNumber ) external returns ( bool _isInitialBufferSlot ); Keep reading to understand the meaning of the parameters. More information in the Attestation Client repository . 5. Consensus # If at least 50% of the attestation providers submitted the same answer, it is made public. Otherwise, no consensus is achieved : requests remain unanswered and must be issued again. The answers are stored in the State Connector smart contract for a week , where anybody can read them. Retrieving your request's answer (for App developers) To retrieve the stored answers just read the merkleRoots public array (#8) in the StateConnector contract . More information on how to retrieve a particular answer in the State Connector contract source code . As shown below, multiple answers are actually packed into a single Merkle root. The Attestation Packing section explains how to retrieve an individual answer. Attestation Protocols # For simplicity, the above description omitted two very important mechanisms , reviewed here. The main one is Attestation packing , which decouples the number of requests from the number of answers, effectively providing unbounded scalability. It requires requests to be first collected and then answered all at once , so a protocol called RCR is used. Overlapped RCR Protocol # Requests and answers are submitted sequentially in attestation rounds . Each attestation round has 3 90-second consecutive phases, called Request, Commit and Reveal (A whole round therefore takes 4.5 minutes). The Request-Commit-Reveal (RCR) protocol. Request phase : Users send their requests to the State Connector contract which forwards them to every attestation provider. Commit phase : Attestation providers send obfuscated answers to the State Connector, so they cannot cheat by peeking at each other's submissions. Reveal phase : Attestation providers send the deobfuscation key so their previous answers are revealed. When all data is available, answers are made public if there is enough consensus. The RCR protocol is akin to making submissions in a closed envelope which is not opened until all submissions are received. Results are available at the end of the Reveal phase, so the answer to a particular request can take anywhere from 3 to 4.5 minutes , depending on the time in which the request was made inside the Request phase. Furthermore, the phases of the RCR protocol are actually overlapped , so when requests are being requested for round \\(n+2\\) , answers are being simultaneously committed for the previous round \\((n+1)\\) , and revealed for the round prior to that \\((n)\\) . The RCR protocol with overlapped phases. This means that new requests can be made without waiting for the previous ones to be completed. Attestation Packing # Each round, attestation providers build a Merkle tree with the hashes of all valid answers for the round. The obtained Merkle root is then called the Attestation Proof , since it is proof of the presence of each individual answer. Finally, the attestation proof is submitted to the State Connector for consensus evaluation. Attestation Proof packing using a Merkle tree. This allows any number of requests to be answered with a single hash , greatly improving scalability . Furthermore, the gas cost for attestation providers is constant each round, no matter how many requests they are answering. A request is only valid (and therefore added to the proof) if it is well-formed and it matches reality . Different providers might have different views on what reality is, and this is why the State Connector runs a consensus algorithm on the received answers. Additionally, the allowed request types are carefully designed to minimize the probability of contention . For example, requiring some time for transactions to settle before inquiring about them, and forcing requests to include the hash of a later block that confirms the transaction. Attestation providers keep the actual retrieved data for a week, in case it contains additional information beyond the yes/no result. Users can request this data directly from the providers through the Proof API . Note Please note that this data is safe to use even though it is obtained directly from the provider, because its hash is consistent with the Attestation Proof agreed upon by the State Connector's consensus. See the \"Proof unpacking\" box below to learn how to verify the data. Additional points worth noting: If two attestation providers observe a different validity for any of the requests in the round, they will submit a completely different Attestation Proof. Attestation providers must answer all queries in the round or abstain from participating in the round , otherwise, their Merkle tree root will not match other providers and will probably be discarded by consensus. Hashes are sorted before being added to the tree, just to have a consistent ordering (albeit arbitrary). The Merkle tree can later be swapped by more efficient algorithms without impacting the State Connector contract, which will continue to vote only on the root hash. Proof Unpacking (for App developers) The procedure for apps to check whether the State Connector answered yes or no to their request is detailed in the Attestation Client repository . What follows is an illustrative summary. The basic idea is that you must retrieve all data (both requests and answers) for the round from an attestation provider. You then rebuild the Merkle tree with this data and check that it matches the Attestation Proof provided by the State Connector. Proof unpacking. In the attestation round after you made the request (3 attestation phases, so from 3 to 4.5 minutes) the Attestation Proof for the round should be available in the State Connector. Retrieve it using method getAttestation (#7) of the StateConnector contract . Select any attestation provider you want and use the Proof API path api/proof/votes-for-round/{roundId} to retrieve all data for the round . Rebuild the Merkle tree for the retrieved data. There are tools to help you, like the MerkleTree.ts library. Check that the tree's root matches the Attestation Proof from step 1. If it does not match, this provider did not submit the answer agreed by the majority. Choose another provider in step 2. Now that you know that the retrieved data has been agreed upon by the consensus, you can use it. Look for your request inside the returned data . If it is not present, your request was deemed invalid (e.g. the queried transaction was not present). Otherwise, your request is valid and you can find any extra information about it in the data array. Branching Protocol # Besides the consensus algorithm that runs on all received attestations, the State Connector provides one further security mechanism : the ability of any individual validator node to fork and halt execution if attestation providers specially trusted by it disagree with the majority. Attestation Provider Sets # To achieve this, two sets of attestation providers are defined: Default attestation providers set Anybody can submit attestations to the State Connector, but the contract will only accept submissions from attestation providers in the default set . This list was managed by Flare at launch and later became completely decentralized (see the section Becoming an Attestation Provider for more information). Every validator node in the Flare network relies on this set. Local attestation providers set Additionally, each node operator can provide a list of local attestation providers to be accepted besides the ones from the default set. Local providers are the same kind of nodes as default providers, and they are treated exactly the same by the State Connector. Furthermore, providers can belong to both sets. Default and Local attestation providers. Then, for an attestation round to succeed these three conditions must be met: The default set must agree on a result (50% consensus inside the set). The local set must agree on a result too (50% consensus inside the set). Both results must match . Otherwise, the round is undecided and no answer is made public. This gives local attestation providers the capacity to stop results from being approved if they don't agree with their own observations. Ideally, local providers are managed by the same entity controlling the validator node using them, so they can be trusted implicitly . As a consequence of different validators using different attestation providers, sometimes State Connector queries can get different results on some validators, which naturally leads to chain forks . Typically, blockchains allow every branch in a fork to coexist and grow independently , until the discrepancy is detected and resolved. At that point, any branches deemed invalid are removed and all the validators that were following them experience a rollback : All transactions that happened after the fork are reverted and the state of those validators is synchronized with the rest of the network. When dealing with forks caused by the State Connector, the Flare network implements an extra security measure : Validators whose local attestation providers disagree with the default set halt execution after the fork , ensuring that they will not suffer any rollback once the fork is resolved. In other words, these validators remain in a safe state in which the disputed query is undecided and therefore no action is taken based on it. Example State Connector forks. In the example picture , all validator nodes use the attestation providers from the default set (not shown), but validators on the rightmost column, additionally, employ local providers . One of them returns a different answer for one of the queries, which leads to a fork of the chain since that validator's state does not match the rest of the network (the divergent ledger, depicted in red). The next section shows how forks are resolved and halted nodes restarted. Branch Resolution # The two states of the branching protocol. The picture above shows the state of the network after a fork. The default network state is the one followed by validators which only use the default set of attestation providers . The alternate network state is where validators go if they use local attestation providers , and they disagree with the default set. In the alternate state no queries are answered and no blocks are produced , so it is a safe state for validators to wait for forks to be resolved. This resolution must come from operators when they are alerted that a validator node has stopped. To understand how to do this, note that attestations are designed to be objectively decidable , meaning that in the event of a fork one branch matches reality and the other does not . There are therefore only two ways to resolve a fork: When local providers are wrong : The operator of the separated validator needs to find out why the local attestation providers failed and either fix them or remove them from the local set of the validator. Once this is fixed, the node simply rewinds its state to where it split and quickly fast-forward to rejoin the default state. Fork resolution when local providers are wrong. Note that no transactions need to be rolled back , on either branch. In the event of this kind of fork, dapps depending on information from a separated validator just have to wait longer to get their result. When the default set is wrong : First off, this is a very delicate situation and it should be rare . The default set uses consensus among attestation providers which have been chosen due to their merits as FTSO data providers. The fact that more than 50% of them are reporting data inconsistent with reality can be considered a 51% attack . The operator of the separated validator, upon convincing themselves that their branch is the correct one (it matches reality) they need to bring the fork to the attention of the misbehaving attestation providers' operators. All validators in the default state then need to roll back to the last correct state (reverting transactions) and continue from there on the forked branch, which becomes the new default state. Fork resolution when the default set is wrong. Note that stopped nodes can resume now, and they never had to roll back any transaction . In summary, validators using at least one reliable local attestation provider do not have to worry about rollbacks, even in the face of 51% attacks . Becoming an Attestation Provider # Anyone may operate an attestation provider without any capital requirement (see the attestation-client repository for deployment information), which can readily be used as a local provider on validators that trust it. To be included in the default set , though, the same operator must run one of the top-performing FTSO data providers to prove its commitment to the network's well-being. More details will be added soon. Adding New Attestation Types # New real-world event-type integrations are introduced to the State Connector via acceptance by the default attestation providers, without requiring any changes to the core voting or branching protocols described above. This enables rapid deployment of new use-cases without any validator-level code changes. See the state-connector-attestation-types repository for more information.","title":"State Connector"},{"location":"tech/state-connector/#state-connector","text":"","title":"State Connector"},{"location":"tech/state-connector/#introduction","text":"The State Connector is a smart contract running on the Flare network that allows anyone to query information from outside the Flare network . It does so in a decentralized manner (no single party is in control of the process) and securely (it takes a lot of effort to disrupt the process). This is accomplished by using a set of independent attestation providers which fetch the required information from the world and deliver it to the Flare network. The State Connector smart contract then checks if there is enough consensus among the received answers and publishes the results if so. As an added security measure, individual validators can also define local attestation providers which, when in disagreement with the rest, cause the validator to branch into an idle, safe state while the situation is resolved. The State Connector. The State Connector can, for instance, check whether a deposit has been made on another blockchain , opening the door to more advanced mechanisms like the FAsset or the LayerCake bridges. This page gives technical details about the whole procedure, the different security and scalability measures that have been taken into account in its design and the kind of queries that can be performed.","title":"Introduction"},{"location":"tech/state-connector/#procedure-overview","text":"This is how user queries are processed. The following sections contain more details. State Connector procedure overview.","title":"Procedure Overview"},{"location":"tech/state-connector/#1-request","text":"Anybody, be it a smart contract running on Flare or an application, can request the attestation of a specific event from the State Connector. Requests are yes/no questions regarding things that happened outside the Flare network, for example, \"Has transaction 0xABC been confirmed on the Bitcoin network enough times?\". The answers, though, might contain any kind of additional data attached, like the content of transaction 0xABC, for example. Requests must adhere to one of the available request types , which have been designed to be strictly decidable , i.e., the answers are objective and cannot be argued. Otherwise, queries like \"What is the weather like in Paris?\" would have a hard time reaching consensus among the different attestation providers. Section Adding New Attestation Types below contains more details. Making a request (for App developers) Make your requests using the requestAttestations method (#2) of the StateConnector contract : function requestAttestations ( bytes calldata data ) external ; The requestAttestations method has a single parameter, data , which is a byte array with a content that depends on the desired request type . You can learn how to build this array in the state-connector-attestation-types repository .","title":"1. Request"},{"location":"tech/state-connector/#2-request-forwarding","text":"The State Connector simply forwards the request to all connected attestation providers through an EVM event. Therefore, the request is not stored on the blockchain and its gas cost is very low for the requester.","title":"2. Request forwarding"},{"location":"tech/state-connector/#3-data-retrieval","text":"Attestation providers fetch the requested data by means that depend on the type of attestation. E.g., retrieving data from another blockchain or public API. Keep in mind that attestation providers are not controlled by Flare in any way. Anybody can listen to the request events and provide answers using any combination of hardware, software and code they see fit.","title":"3. Data retrieval"},{"location":"tech/state-connector/#4-attestation","text":"To prevent attestation providers from peeking at each other's answers, these are submitted in a \"Commit and Reveal\" fashion called the RCR protocol and detailed below. Submitting an attestation (For attestation provider developers) Attestation providers use the submitAttestation method (#3) of the StateConnector contract : function submitAttestation ( uint256 _bufferNumber , bytes32 _commitHash , bytes32 _merkleRoot , bytes32 _randomNumber ) external returns ( bool _isInitialBufferSlot ); Keep reading to understand the meaning of the parameters. More information in the Attestation Client repository .","title":"4. Attestation"},{"location":"tech/state-connector/#5-consensus","text":"If at least 50% of the attestation providers submitted the same answer, it is made public. Otherwise, no consensus is achieved : requests remain unanswered and must be issued again. The answers are stored in the State Connector smart contract for a week , where anybody can read them. Retrieving your request's answer (for App developers) To retrieve the stored answers just read the merkleRoots public array (#8) in the StateConnector contract . More information on how to retrieve a particular answer in the State Connector contract source code . As shown below, multiple answers are actually packed into a single Merkle root. The Attestation Packing section explains how to retrieve an individual answer.","title":"5. Consensus"},{"location":"tech/state-connector/#attestation-protocols","text":"For simplicity, the above description omitted two very important mechanisms , reviewed here. The main one is Attestation packing , which decouples the number of requests from the number of answers, effectively providing unbounded scalability. It requires requests to be first collected and then answered all at once , so a protocol called RCR is used.","title":"Attestation Protocols"},{"location":"tech/state-connector/#overlapped-rcr-protocol","text":"Requests and answers are submitted sequentially in attestation rounds . Each attestation round has 3 90-second consecutive phases, called Request, Commit and Reveal (A whole round therefore takes 4.5 minutes). The Request-Commit-Reveal (RCR) protocol. Request phase : Users send their requests to the State Connector contract which forwards them to every attestation provider. Commit phase : Attestation providers send obfuscated answers to the State Connector, so they cannot cheat by peeking at each other's submissions. Reveal phase : Attestation providers send the deobfuscation key so their previous answers are revealed. When all data is available, answers are made public if there is enough consensus. The RCR protocol is akin to making submissions in a closed envelope which is not opened until all submissions are received. Results are available at the end of the Reveal phase, so the answer to a particular request can take anywhere from 3 to 4.5 minutes , depending on the time in which the request was made inside the Request phase. Furthermore, the phases of the RCR protocol are actually overlapped , so when requests are being requested for round \\(n+2\\) , answers are being simultaneously committed for the previous round \\((n+1)\\) , and revealed for the round prior to that \\((n)\\) . The RCR protocol with overlapped phases. This means that new requests can be made without waiting for the previous ones to be completed.","title":"Overlapped RCR Protocol"},{"location":"tech/state-connector/#attestation-packing","text":"Each round, attestation providers build a Merkle tree with the hashes of all valid answers for the round. The obtained Merkle root is then called the Attestation Proof , since it is proof of the presence of each individual answer. Finally, the attestation proof is submitted to the State Connector for consensus evaluation. Attestation Proof packing using a Merkle tree. This allows any number of requests to be answered with a single hash , greatly improving scalability . Furthermore, the gas cost for attestation providers is constant each round, no matter how many requests they are answering. A request is only valid (and therefore added to the proof) if it is well-formed and it matches reality . Different providers might have different views on what reality is, and this is why the State Connector runs a consensus algorithm on the received answers. Additionally, the allowed request types are carefully designed to minimize the probability of contention . For example, requiring some time for transactions to settle before inquiring about them, and forcing requests to include the hash of a later block that confirms the transaction. Attestation providers keep the actual retrieved data for a week, in case it contains additional information beyond the yes/no result. Users can request this data directly from the providers through the Proof API . Note Please note that this data is safe to use even though it is obtained directly from the provider, because its hash is consistent with the Attestation Proof agreed upon by the State Connector's consensus. See the \"Proof unpacking\" box below to learn how to verify the data. Additional points worth noting: If two attestation providers observe a different validity for any of the requests in the round, they will submit a completely different Attestation Proof. Attestation providers must answer all queries in the round or abstain from participating in the round , otherwise, their Merkle tree root will not match other providers and will probably be discarded by consensus. Hashes are sorted before being added to the tree, just to have a consistent ordering (albeit arbitrary). The Merkle tree can later be swapped by more efficient algorithms without impacting the State Connector contract, which will continue to vote only on the root hash. Proof Unpacking (for App developers) The procedure for apps to check whether the State Connector answered yes or no to their request is detailed in the Attestation Client repository . What follows is an illustrative summary. The basic idea is that you must retrieve all data (both requests and answers) for the round from an attestation provider. You then rebuild the Merkle tree with this data and check that it matches the Attestation Proof provided by the State Connector. Proof unpacking. In the attestation round after you made the request (3 attestation phases, so from 3 to 4.5 minutes) the Attestation Proof for the round should be available in the State Connector. Retrieve it using method getAttestation (#7) of the StateConnector contract . Select any attestation provider you want and use the Proof API path api/proof/votes-for-round/{roundId} to retrieve all data for the round . Rebuild the Merkle tree for the retrieved data. There are tools to help you, like the MerkleTree.ts library. Check that the tree's root matches the Attestation Proof from step 1. If it does not match, this provider did not submit the answer agreed by the majority. Choose another provider in step 2. Now that you know that the retrieved data has been agreed upon by the consensus, you can use it. Look for your request inside the returned data . If it is not present, your request was deemed invalid (e.g. the queried transaction was not present). Otherwise, your request is valid and you can find any extra information about it in the data array.","title":"Attestation Packing"},{"location":"tech/state-connector/#branching-protocol","text":"Besides the consensus algorithm that runs on all received attestations, the State Connector provides one further security mechanism : the ability of any individual validator node to fork and halt execution if attestation providers specially trusted by it disagree with the majority.","title":"Branching Protocol"},{"location":"tech/state-connector/#attestation-provider-sets","text":"To achieve this, two sets of attestation providers are defined: Default attestation providers set Anybody can submit attestations to the State Connector, but the contract will only accept submissions from attestation providers in the default set . This list was managed by Flare at launch and later became completely decentralized (see the section Becoming an Attestation Provider for more information). Every validator node in the Flare network relies on this set. Local attestation providers set Additionally, each node operator can provide a list of local attestation providers to be accepted besides the ones from the default set. Local providers are the same kind of nodes as default providers, and they are treated exactly the same by the State Connector. Furthermore, providers can belong to both sets. Default and Local attestation providers. Then, for an attestation round to succeed these three conditions must be met: The default set must agree on a result (50% consensus inside the set). The local set must agree on a result too (50% consensus inside the set). Both results must match . Otherwise, the round is undecided and no answer is made public. This gives local attestation providers the capacity to stop results from being approved if they don't agree with their own observations. Ideally, local providers are managed by the same entity controlling the validator node using them, so they can be trusted implicitly . As a consequence of different validators using different attestation providers, sometimes State Connector queries can get different results on some validators, which naturally leads to chain forks . Typically, blockchains allow every branch in a fork to coexist and grow independently , until the discrepancy is detected and resolved. At that point, any branches deemed invalid are removed and all the validators that were following them experience a rollback : All transactions that happened after the fork are reverted and the state of those validators is synchronized with the rest of the network. When dealing with forks caused by the State Connector, the Flare network implements an extra security measure : Validators whose local attestation providers disagree with the default set halt execution after the fork , ensuring that they will not suffer any rollback once the fork is resolved. In other words, these validators remain in a safe state in which the disputed query is undecided and therefore no action is taken based on it. Example State Connector forks. In the example picture , all validator nodes use the attestation providers from the default set (not shown), but validators on the rightmost column, additionally, employ local providers . One of them returns a different answer for one of the queries, which leads to a fork of the chain since that validator's state does not match the rest of the network (the divergent ledger, depicted in red). The next section shows how forks are resolved and halted nodes restarted.","title":"Attestation Provider Sets"},{"location":"tech/state-connector/#branch-resolution","text":"The two states of the branching protocol. The picture above shows the state of the network after a fork. The default network state is the one followed by validators which only use the default set of attestation providers . The alternate network state is where validators go if they use local attestation providers , and they disagree with the default set. In the alternate state no queries are answered and no blocks are produced , so it is a safe state for validators to wait for forks to be resolved. This resolution must come from operators when they are alerted that a validator node has stopped. To understand how to do this, note that attestations are designed to be objectively decidable , meaning that in the event of a fork one branch matches reality and the other does not . There are therefore only two ways to resolve a fork: When local providers are wrong : The operator of the separated validator needs to find out why the local attestation providers failed and either fix them or remove them from the local set of the validator. Once this is fixed, the node simply rewinds its state to where it split and quickly fast-forward to rejoin the default state. Fork resolution when local providers are wrong. Note that no transactions need to be rolled back , on either branch. In the event of this kind of fork, dapps depending on information from a separated validator just have to wait longer to get their result. When the default set is wrong : First off, this is a very delicate situation and it should be rare . The default set uses consensus among attestation providers which have been chosen due to their merits as FTSO data providers. The fact that more than 50% of them are reporting data inconsistent with reality can be considered a 51% attack . The operator of the separated validator, upon convincing themselves that their branch is the correct one (it matches reality) they need to bring the fork to the attention of the misbehaving attestation providers' operators. All validators in the default state then need to roll back to the last correct state (reverting transactions) and continue from there on the forked branch, which becomes the new default state. Fork resolution when the default set is wrong. Note that stopped nodes can resume now, and they never had to roll back any transaction . In summary, validators using at least one reliable local attestation provider do not have to worry about rollbacks, even in the face of 51% attacks .","title":"Branch Resolution"},{"location":"tech/state-connector/#becoming-an-attestation-provider","text":"Anyone may operate an attestation provider without any capital requirement (see the attestation-client repository for deployment information), which can readily be used as a local provider on validators that trust it. To be included in the default set , though, the same operator must run one of the top-performing FTSO data providers to prove its commitment to the network's well-being. More details will be added soon.","title":"Becoming an Attestation Provider"},{"location":"tech/state-connector/#adding-new-attestation-types","text":"New real-world event-type integrations are introduced to the State Connector via acceptance by the default attestation providers, without requiring any changes to the core voting or branching protocols described above. This enables rapid deployment of new use-cases without any validator-level code changes. See the state-connector-attestation-types repository for more information.","title":"Adding New Attestation Types"},{"location":"tech/validators/","text":"Validator Nodes # Validator nodes are online servers running a blockchain's client software. They all keep a copy of the ledger and are constantly talking to each other to make sure the copies are consistent as new data is added. A network of validator nodes, each one with an identical copy of the ledger. The fact that the ledger is not under control of a single entity but distributed among a network of independent validators is what makes blockchains: Require less trust than traditional options. Censorship resistant. Byzantine fault tolerant . Validators agree on the state of the ledger using a consensus algorithm that varies for each blockchain. While the implementation of the groundbreaking FCP protocol is being completed, Flare is currently using a variant of Avalanche 's Snowman++ algorithm. In Avalanche's Snowman++, each round a validator is randomly selected to act as the leader and propose new blocks to be added to the ledger, which are then validated by the rest of nodes. To provide Sybil resistance , the probability of a node's being elected the leader is proportional to the node's stake , so this is effectively a Proof-of-Stake consensus. The shortcomings of Proof-of-stake are well known and include risk of centralization and the rich-get-richer effect , for example. To compensate for this, Flare's version of Snowman++ reduces the importance of a node's stake and introduces a meritocratic factor : All Flare validators are also FTSO Data Providers , so their performance in this role has an impact on their chance to become round leaders. More precisely, the probability \\(P\\) of being the leader depends both on a node's stake ( \\(VotePower\\) ) and on its performance as a Data Provider (evaluated through its \\(RewardRate\\) ) like this: \\[ P = \\log (VotePower) * RewardRate \\] And then normalized so the probabilities for all nodes add up to \\(1.0\\) . As it can be seen: The logarithm (which might be replaced by a square root or similar compressing function) reduces the importance of large stakes. Multiplying by the \\(RewardRate\\) benefits the nodes that consistently provide good FTSO data. Both the \\(VotePower\\) and the \\(RewardRate\\) are evaluated once a week based on the previous week's results. The plots below show the equalizing effect of this formula on actual data taken from flaremetrics.io : Left: Probabilities based solely on stake. Right: Probablities based on diminished stake and FTSO performance. As it is readily apparent, the distribution to the right is far more egalitarian, while still rewarding high stakes and FTSO performance.","title":"Validator Nodes"},{"location":"tech/validators/#validator-nodes","text":"Validator nodes are online servers running a blockchain's client software. They all keep a copy of the ledger and are constantly talking to each other to make sure the copies are consistent as new data is added. A network of validator nodes, each one with an identical copy of the ledger. The fact that the ledger is not under control of a single entity but distributed among a network of independent validators is what makes blockchains: Require less trust than traditional options. Censorship resistant. Byzantine fault tolerant . Validators agree on the state of the ledger using a consensus algorithm that varies for each blockchain. While the implementation of the groundbreaking FCP protocol is being completed, Flare is currently using a variant of Avalanche 's Snowman++ algorithm. In Avalanche's Snowman++, each round a validator is randomly selected to act as the leader and propose new blocks to be added to the ledger, which are then validated by the rest of nodes. To provide Sybil resistance , the probability of a node's being elected the leader is proportional to the node's stake , so this is effectively a Proof-of-Stake consensus. The shortcomings of Proof-of-stake are well known and include risk of centralization and the rich-get-richer effect , for example. To compensate for this, Flare's version of Snowman++ reduces the importance of a node's stake and introduces a meritocratic factor : All Flare validators are also FTSO Data Providers , so their performance in this role has an impact on their chance to become round leaders. More precisely, the probability \\(P\\) of being the leader depends both on a node's stake ( \\(VotePower\\) ) and on its performance as a Data Provider (evaluated through its \\(RewardRate\\) ) like this: \\[ P = \\log (VotePower) * RewardRate \\] And then normalized so the probabilities for all nodes add up to \\(1.0\\) . As it can be seen: The logarithm (which might be replaced by a square root or similar compressing function) reduces the importance of large stakes. Multiplying by the \\(RewardRate\\) benefits the nodes that consistently provide good FTSO data. Both the \\(VotePower\\) and the \\(RewardRate\\) are evaluated once a week based on the previous week's results. The plots below show the equalizing effect of this formula on actual data taken from flaremetrics.io : Left: Probabilities based solely on stake. Right: Probablities based on diminished stake and FTSO performance. As it is readily apparent, the distribution to the right is far more egalitarian, while still rewarding high stakes and FTSO performance.","title":"Validator Nodes"},{"location":"user/","text":"User Guides # This section contains step-by-step guides on how to use tools like the Block Explorer or the different wallets.","title":"User Guides"},{"location":"user/#user-guides","text":"This section contains step-by-step guides on how to use tools like the Block Explorer or the different wallets.","title":"User Guides"},{"location":"user/block-explorer/","text":"Block Explorer # Flare provides block explorers for all its networks: Flare explorer Songbird explorer Coston explorer All explorers are a fork of Blockscout , adapted to the Flare networks ( Blockscout Docs ). API access to the Coston Explorer is enabled for non-commercial use only: API Docs . See some Explorer API examples: Flare Examples Songbird Examples Coston Examples Note Make sure to follow the Metadata section of the ERC-1155 standard to display NFTs correctly in the explorer.","title":"Block Explorer"},{"location":"user/block-explorer/#block-explorer","text":"Flare provides block explorers for all its networks: Flare explorer Songbird explorer Coston explorer All explorers are a fork of Blockscout , adapted to the Flare networks ( Blockscout Docs ). API access to the Coston Explorer is enabled for non-commercial use only: API Docs . See some Explorer API examples: Flare Examples Songbird Examples Coston Examples Note Make sure to follow the Metadata section of the ERC-1155 standard to display NFTs correctly in the explorer.","title":"Block Explorer"},{"location":"user/delegation/","text":"Delegation overview # Any user holding Flare tokens, whether $FLR on Flare or $SGB on Songbird, can delegate its vote power to price providers in the Flare FTSO system . Price providers submit price signals to the Flare Time Series Oracle system (FTSO). Inflation is distributed to anyone participating in the FTSO, which includes price providers and any user delegating its vote power to the price providers. By participating, any token holder can earn a part of the distributed inflation. Each user can delegate its vote power without a locking scheme. This means users can earn rewards for their tokens without locking them, so they can still be used for other purposes. To delegate vote power tokens need to be wrapped into Wrapped Flare ( $WFLR ) or Wrapped Songbird ( $WSGB ). Once this is done, the user will have the vote power that is equivalent to its wrapped token balance. Then the user can delegate this vote power to one or two price providers. As long as this delegation is active the user will earn rewards which are aligned with its vote power and the performance of the chosen price provider/s. Those rewards accumulate in the reward manager and will become claimable for each reward epoch that is finalized.","title":"Delegation overview"},{"location":"user/delegation/#delegation-overview","text":"Any user holding Flare tokens, whether $FLR on Flare or $SGB on Songbird, can delegate its vote power to price providers in the Flare FTSO system . Price providers submit price signals to the Flare Time Series Oracle system (FTSO). Inflation is distributed to anyone participating in the FTSO, which includes price providers and any user delegating its vote power to the price providers. By participating, any token holder can earn a part of the distributed inflation. Each user can delegate its vote power without a locking scheme. This means users can earn rewards for their tokens without locking them, so they can still be used for other purposes. To delegate vote power tokens need to be wrapped into Wrapped Flare ( $WFLR ) or Wrapped Songbird ( $WSGB ). Once this is done, the user will have the vote power that is equivalent to its wrapped token balance. Then the user can delegate this vote power to one or two price providers. As long as this delegation is active the user will earn rewards which are aligned with its vote power and the performance of the chosen price provider/s. Those rewards accumulate in the reward manager and will become claimable for each reward epoch that is finalized.","title":"Delegation overview"},{"location":"user/delegation/delegation-faq/","text":"Delegation FAQ # Why should I delegate? # When delegating your vote power, you can earn rewards, but even more importantly, you can support reliable price providers which in turn will strengthen the stability of the FTSO and the whole ecosystem. Can I still use my tokens after delegating my vote power? # Yes. The tokens are never locked and can be used for any purpose: send, deposit etc. Do I lose ownership of my tokens when delegating my vote power? # No, delegation never requires giving up ownership of your tokens. What is the first step for delegating my vote power? # The first step is to wrap your native tokens ( $FLR or $SGB ) into $WFLR or $WSGB . Wrapped tokens have a 1:1 conversion to native tokens. This is a fundamental step for enabling users to delegate their vote power. How do I wrap my native tokens? # Through a supported wallet: see the wallets section . Through a dapp : some FTSO data providers have already started providing these dapps as a convenience. Take a look at flaremetrics.io and pick the one you prefer. Through direct interaction with the blockchain, once you understand manual delegation . How many tokens should I wrap? # Note that gas cannot be paid with wrapped tokens, therefore always make sure not to wrap your full native holdings. Rather, keep some tokens unwrapped for paying gas fees with your account. How do I delegate my vote power? # Same mechanisms as explained in How do I wrap my native tokens? above. How much vote power should I delegate? # Once you own wrapped tokens, it is best to delegate 100% of your vote power. To whom should I delegate my vote power? # For the ongoing stability of the FTSO it is highly recommended delegating to reliable price providers, i.e., ones that are committed to providing accurate price feeds. Consider the expected reward rate each price provider can offer. See flaremetrics.io for a list of FTSO data providers. How many price providers can I delegate to? # Each user can delegate to one or two price providers. Should I delegate to one or two price providers? # For an account with a low balance (~ 500 tokens) it is better to delegate to 1 price provider, since the gas amount when claiming rewards for two providers is a bit higher. If you have a larger account, consider delegating to two price providers. When I send or receive tokens is my delegation data automatically updated? # Yes, if a user is using delegation by percentage, which means any $WFLR or $WSGB that is newly wrapped, sent or received will automatically update the actual delegated vote power. On the other hand, if you receive native tokens, you have to first wrap them to be able to contribute to existing delegations. What if I want to update my delegations? # When updating delegation data the total percentage should always be equal to or smaller than 100%. So if you want to reduce some percentage from one price provider and increase for the other, you should first decrease the percentage from one price provider. When is my delegation reflected? # Your delegation is reflected in the next reward epoch if it happens before the vote power snapshot . Any delegation done after the snapshot block will only be reflected once the next reward epoch ends . Do claimed, wrapped and delegated tokens become immediately effective in the ongoing reward epoch? # No. In general, they start becoming effective for rewards in the next reward epoch, that is assuming wrapping and delegation were carried out before the vote power snapshot block. When is the snapshot vote power taken for a reward epoch? # A vote power block snapshot for current reward epoch is selected randomly and retroactively at the beginning of a new epoch. It is selected from the last half (on Flare) or the last quarter (on Songbird) of the previous reward epoch (in terms of blocks produced in the previous reward epoch). Why should I avoid delegating in the last half or quarter of the current reward epoch? # Your delegation might be too late for consideration in the next reward epoch since the vote power block for the next reward epoch will be randomly chosen from the blocks in the last half (on Flare) or quarter (on Songbird) of the current epoch. How much reward can each price provider earn for me? # This depends on a few factors: The delegated balance. The price provider reward rate. The price provider fee. How much fee does the price provider take from addresses delegating to it. The amount of vote power already delegated to this price provider. To encourage decentralization, there is a vote power cap and any excess vote power is not counted during the median calculation and rewarding phase. If there is over delegation, the same amount of rewards is split between more delegators. Where can I see the expected rewards from a price provider? # Each price provider has different performance that results in different reward rates. Sources for this data can be found on the web. Note the reward rate might be changing per each week. Try googling for \"Flare metrics\".","title":"Delegation FAQ"},{"location":"user/delegation/delegation-faq/#delegation-faq","text":"","title":"Delegation FAQ"},{"location":"user/delegation/delegation-faq/#why-should-i-delegate","text":"When delegating your vote power, you can earn rewards, but even more importantly, you can support reliable price providers which in turn will strengthen the stability of the FTSO and the whole ecosystem.","title":"Why should I delegate?"},{"location":"user/delegation/delegation-faq/#can-i-still-use-my-tokens-after-delegating-my-vote-power","text":"Yes. The tokens are never locked and can be used for any purpose: send, deposit etc.","title":"Can I still use my tokens after delegating my vote power?"},{"location":"user/delegation/delegation-faq/#do-i-lose-ownership-of-my-tokens-when-delegating-my-vote-power","text":"No, delegation never requires giving up ownership of your tokens.","title":"Do I lose ownership of my tokens when delegating my vote power?"},{"location":"user/delegation/delegation-faq/#what-is-the-first-step-for-delegating-my-vote-power","text":"The first step is to wrap your native tokens ( $FLR or $SGB ) into $WFLR or $WSGB . Wrapped tokens have a 1:1 conversion to native tokens. This is a fundamental step for enabling users to delegate their vote power.","title":"What is the first step for delegating my vote power?"},{"location":"user/delegation/delegation-faq/#how-do-i-wrap-my-native-tokens","text":"Through a supported wallet: see the wallets section . Through a dapp : some FTSO data providers have already started providing these dapps as a convenience. Take a look at flaremetrics.io and pick the one you prefer. Through direct interaction with the blockchain, once you understand manual delegation .","title":"How do I wrap my native tokens?"},{"location":"user/delegation/delegation-faq/#how-many-tokens-should-i-wrap","text":"Note that gas cannot be paid with wrapped tokens, therefore always make sure not to wrap your full native holdings. Rather, keep some tokens unwrapped for paying gas fees with your account.","title":"How many tokens should I wrap?"},{"location":"user/delegation/delegation-faq/#how-do-i-delegate-my-vote-power","text":"Same mechanisms as explained in How do I wrap my native tokens? above.","title":"How do I delegate my vote power?"},{"location":"user/delegation/delegation-faq/#how-much-vote-power-should-i-delegate","text":"Once you own wrapped tokens, it is best to delegate 100% of your vote power.","title":"How much vote power should I delegate?"},{"location":"user/delegation/delegation-faq/#to-whom-should-i-delegate-my-vote-power","text":"For the ongoing stability of the FTSO it is highly recommended delegating to reliable price providers, i.e., ones that are committed to providing accurate price feeds. Consider the expected reward rate each price provider can offer. See flaremetrics.io for a list of FTSO data providers.","title":"To whom should I delegate my vote power?"},{"location":"user/delegation/delegation-faq/#how-many-price-providers-can-i-delegate-to","text":"Each user can delegate to one or two price providers.","title":"How many price providers can I delegate to?"},{"location":"user/delegation/delegation-faq/#should-i-delegate-to-one-or-two-price-providers","text":"For an account with a low balance (~ 500 tokens) it is better to delegate to 1 price provider, since the gas amount when claiming rewards for two providers is a bit higher. If you have a larger account, consider delegating to two price providers.","title":"Should I delegate to one or two price providers?"},{"location":"user/delegation/delegation-faq/#when-i-send-or-receive-tokens-is-my-delegation-data-automatically-updated","text":"Yes, if a user is using delegation by percentage, which means any $WFLR or $WSGB that is newly wrapped, sent or received will automatically update the actual delegated vote power. On the other hand, if you receive native tokens, you have to first wrap them to be able to contribute to existing delegations.","title":"When I send or receive tokens is my delegation data automatically updated?"},{"location":"user/delegation/delegation-faq/#what-if-i-want-to-update-my-delegations","text":"When updating delegation data the total percentage should always be equal to or smaller than 100%. So if you want to reduce some percentage from one price provider and increase for the other, you should first decrease the percentage from one price provider.","title":"What if I want to update my delegations?"},{"location":"user/delegation/delegation-faq/#when-is-my-delegation-reflected","text":"Your delegation is reflected in the next reward epoch if it happens before the vote power snapshot . Any delegation done after the snapshot block will only be reflected once the next reward epoch ends .","title":"When is my delegation reflected?"},{"location":"user/delegation/delegation-faq/#do-claimed-wrapped-and-delegated-tokens-become-immediately-effective-in-the-ongoing-reward-epoch","text":"No. In general, they start becoming effective for rewards in the next reward epoch, that is assuming wrapping and delegation were carried out before the vote power snapshot block.","title":"Do claimed, wrapped and delegated tokens become immediately effective in the ongoing reward epoch?"},{"location":"user/delegation/delegation-faq/#when-is-the-snapshot-vote-power-taken-for-a-reward-epoch","text":"A vote power block snapshot for current reward epoch is selected randomly and retroactively at the beginning of a new epoch. It is selected from the last half (on Flare) or the last quarter (on Songbird) of the previous reward epoch (in terms of blocks produced in the previous reward epoch).","title":"When is the snapshot vote power taken for a reward epoch?"},{"location":"user/delegation/delegation-faq/#why-should-i-avoid-delegating-in-the-last-half-or-quarter-of-the-current-reward-epoch","text":"Your delegation might be too late for consideration in the next reward epoch since the vote power block for the next reward epoch will be randomly chosen from the blocks in the last half (on Flare) or quarter (on Songbird) of the current epoch.","title":"Why should I avoid delegating in the last half or quarter of the current reward epoch?"},{"location":"user/delegation/delegation-faq/#how-much-reward-can-each-price-provider-earn-for-me","text":"This depends on a few factors: The delegated balance. The price provider reward rate. The price provider fee. How much fee does the price provider take from addresses delegating to it. The amount of vote power already delegated to this price provider. To encourage decentralization, there is a vote power cap and any excess vote power is not counted during the median calculation and rewarding phase. If there is over delegation, the same amount of rewards is split between more delegators.","title":"How much reward can each price provider earn for me?"},{"location":"user/delegation/delegation-faq/#where-can-i-see-the-expected-rewards-from-a-price-provider","text":"Each price provider has different performance that results in different reward rates. Sources for this data can be found on the web. Note the reward rate might be changing per each week. Try googling for \"Flare metrics\".","title":"Where can I see the expected rewards from a price provider?"},{"location":"user/delegation/delegation-in-detail/","text":"Delegation in detail # Delegation enables a user to keep holding their balance (tokens) while delegating the vote power this balance represents. Two delegation methods are supported: The basic (normal) delegation is delegation by percentage , the other being explicit delegation . With percentage delegation, any address can delegate a percentage of its holding; this is limited to x addresses. Example: Alice has 20 tokens and delegates 50% to Bob, Bob will have additional vote power of 10 on the top of his own balance (own vote power). This means any transfer of tokens to or from Alice will update 50% of the delegated vote power to Bob If Alice delegates to another address, each token transfer to or from Alice will update the vote power of those other addresses. This in turn will cause higher gas costs for transfer functions. To cap those extra costs, this delegation option has a limited number of delegation destinations. In the case that an address (user or contract) wishes to delegate vote power to more addresses, they have the option of the explicit delegation method . With explicit delegation , an explicit amount of vote power is delegated. While useful, this does create more complications for the user since the balance corresponding to the delegated vote power can\u2019t be transferred. For example, if Alice has 20 tokens and explicitly delegates vote power of 20 to Bob, the delegated balance is actually locked. Alice can\u2019t send out these tokens unless the 20 vote power is explicitly un-delegated. Another complication here is that for each new token received, a new delegate operation has to be performed; vote power will not be automatically delegated upon token reception. The explicit delegation method is built for advanced users or for contracts holding a large number of tokens for different users. Imagine a collateral contract holding many WSGB for many users. Each user depositing tokens might want to delegate to a different set of price providers. Explicit delegation will enable this contract to update the explicit delegation per user deposit and un-delegate every time a user wishes to withdraw its funds. Only one of the delegation methods can be used per address. Furthermore, an address can never change its delegation method: if a user called delegate-explicit once from its address, they will never be able to do a percentage delegation with the same address, and vice versa. The delegation system supports: Delegation of vote power to up to two addresses. Several addresses delegating to a single address. 1 level delegation. If Alice delegates to Bob and Bob delegates to Charlie, Charlie will only get the delegated balance of Bob, and will not be affected by the delegation Alice did. Delegation units are the same as balance units. Check pointing historical data # Token data regarding vote power, delegation, balance and supply is all checkpointed to allow the retrieval of historical values. Per change in any value, a checkpoint is added to the array which includes the updated value and the block number. When trying to read historical data, a binary search is performed on the array. With this, the data retrieval cost grows on a logarithmic scale. Vote power data # The above delegation scheme creates a mapping from balance to vote power for each address. The vote power of each address reflects its own balance plus any delegated vote power from other addresses. Vote power is never reused (double-spent): if vote power is delegated, the delegating address does not have this vote power under its own account. Voting campaigns using the vote power token # Checkpointed vote power data is used in voting campaigns (like FTSO reward epochs, for example). A voting campaign uses a randomly chosen block number from the past (vote power block). When an address (data provider) casts its vote for a specific campaign, its vote power is taken from the vote power block for this campaign. Hence, the vote power of an address for this campaign does not reflect its present balance and delegation but rather the state at the time of the snapshot (in the vote power block). This design allows for a free use of tokens (non-locked) and a consistent vote power snapshot of token holdings. Voting campaigns are a generic concept; in FTSO system, the vote power of price providers is used as an influence in choosing the final price. Each price submission is weighted according to the vote power scheme described here. Revoke # Due to the substantial length of time one past vote power block is used for price submissions, a revoke feature was added. This feature can be used in case any specific price provider is found trying to attack and skew the reported price of the FTSO (flare oracle). In this situation, an off chain process (e.g. twitter storm) calls users to revoke vote power from a specific price provider. The revoke will update the cached value of the vote power for the specific block which is being used for this reward epoch. So if a user revokes its vote power delegation on a specific block, checkpoints for the vote power will not be updated, only the cached vote power values are zeroed. Vote power block selection # The vote power of each price provider is cached and only recalculated at the start of each reward epoch. The selected vote power block (snapshot block) for a new epoch is selected randomly once the reward epoch starts. It is selected randomly with uniform probability from the last half (on Flare) or the last quarter (on Songbird) of mined blocks. This can roughly be approximated as taking the random block in the last half or quarter time-wise, but it is not necessarily correct , as block mining density can change. Example for Songbird # Reward epoch with index 10 started at block 2487672 with timestamp 1637397708 (Saturday, November 20, 2021 8:41:48 AM GMT) and lasted until block 3003881 with timestamp 1638002503 (Saturday, November 27, 2021 8:41:43 AM GMT). This means that 516209 blocks were mined in this epoch and the last quarter of the blocks started with the block number 2487672 + 516209 * 3 / 4 = 2874828 with timestamp 1637817710 (Thursday, November 25, 2021 5:21:50 AM GMT). Any block between 2874828 and 3003881 is therefore eligible for selection as the vote power block. In this reward epoch, block 2881097 with timestamp 1637825442 (Thursday, November 25, 2021 7:30:42 AM GMT) was selected. This is before the last quarter of the week (Thursday, November 25, 2021 2:41:33 PM GMT) if we were to take the timestamp measure. Developer information # Contracts # The VPToken (Vote Power Token) is the base contract for wrapped tokens. This token contract is built to enable delegation of vote power without locking the holder\u2019s token. It works by adding the vote power and delegation functions to the ERC20 token contract. Basically, balance represents vote power; with the additional code, a holder can delegate a percentage of its own vote power to another address and still use their tokens freely. The transfer/mint/burn functions will immediately update the actual vote power being held by the delegator and the vote power of the address it delegates to. All vote power data is being checkpointed by block. For any vote power update due to delegation, transfer, or otherwise, a checkpoint is added. For anyone familiar with the MiniMe token , the checkpoint mechanism is similar, while differing in that more data is being checkpointed. When a voting campaign occurs, a past block will be randomly chosen and all vote power data will be taken from this block. This would actually work like taking a vote power snapshot for a specific block and using that for all addresses voting (providing prices) in the campaign. The random process of choosing a block is designed to mitigate attacks such as flash-loan or short term loans. API # ERC20 APIs. BalanceOfAt(address, block) , totalSupplyAt(block) as in MiniMe token. Delegation and vote power interfaces are described in IIVPToken interface file. Mint and burn APIs are handled in the inheriting contracts. Caching # Due to reward distribution constraints that are described in the FTSO reward manager specification, the same vote power block is used for a rather long period of time. This time frame, named \"reward epoch\", includes many short price epochs. Meaning, FTSO price feeds commencing over a period of a few days will continuously derive vote power from the same vote power block in the past. Usage of the same vote power block for many campaigns calls for a caching mechanism. The caching mechanism stores the vote power per address per block if done through a dedicated caching enabled function. For example, the normal vote power query function is votePowerOfAt(address, block) . This has a matching cache query: votePowerOfAtCache(address, block) which also caches the data on its first usage for a specific address and block. Later calls to both of these functions will use the cached value if it exists. Retrieving historical data # A large part of the native token inflation is distributed to participants in the FTSO price submission process. The reward won by a price provider is shared between the price provider and the vote power delegators to the price provider. The VP token exposes APIs that enable delegators to see how much vote power was delegated to a price provider in any past block. To enable this, the delegation percentage data are checkpointed after every change. Using the combination of delegation percentage and historical balance, each user can accurately see and show how much vote power they delegated to any address in the past. This API is also used by the reward manager, when the reward sharing is calculated. For explicit delegation, historical data is limited. It would be quite costly to continuously update a list of independent explicit delegations. That being said, when rewards are claimed for addresses that used explicit delegation, the delegator must already know which data providers it delegated vote power to in the relevant block. To recap, historical delegation APIs exist. For percentage delegations, each address can determine the full list of addresses it delegated to in any block in history. For explicit delegations, a user must use their own methods to build the list of addresses it delegated to at specific times. After building this list, one can query how much vote power was delegated to each address. Two options for building this list would be: Saving this data in real time while delegating. Reading past delegation events for this address.","title":"Delegation in detail"},{"location":"user/delegation/delegation-in-detail/#delegation-in-detail","text":"Delegation enables a user to keep holding their balance (tokens) while delegating the vote power this balance represents. Two delegation methods are supported: The basic (normal) delegation is delegation by percentage , the other being explicit delegation . With percentage delegation, any address can delegate a percentage of its holding; this is limited to x addresses. Example: Alice has 20 tokens and delegates 50% to Bob, Bob will have additional vote power of 10 on the top of his own balance (own vote power). This means any transfer of tokens to or from Alice will update 50% of the delegated vote power to Bob If Alice delegates to another address, each token transfer to or from Alice will update the vote power of those other addresses. This in turn will cause higher gas costs for transfer functions. To cap those extra costs, this delegation option has a limited number of delegation destinations. In the case that an address (user or contract) wishes to delegate vote power to more addresses, they have the option of the explicit delegation method . With explicit delegation , an explicit amount of vote power is delegated. While useful, this does create more complications for the user since the balance corresponding to the delegated vote power can\u2019t be transferred. For example, if Alice has 20 tokens and explicitly delegates vote power of 20 to Bob, the delegated balance is actually locked. Alice can\u2019t send out these tokens unless the 20 vote power is explicitly un-delegated. Another complication here is that for each new token received, a new delegate operation has to be performed; vote power will not be automatically delegated upon token reception. The explicit delegation method is built for advanced users or for contracts holding a large number of tokens for different users. Imagine a collateral contract holding many WSGB for many users. Each user depositing tokens might want to delegate to a different set of price providers. Explicit delegation will enable this contract to update the explicit delegation per user deposit and un-delegate every time a user wishes to withdraw its funds. Only one of the delegation methods can be used per address. Furthermore, an address can never change its delegation method: if a user called delegate-explicit once from its address, they will never be able to do a percentage delegation with the same address, and vice versa. The delegation system supports: Delegation of vote power to up to two addresses. Several addresses delegating to a single address. 1 level delegation. If Alice delegates to Bob and Bob delegates to Charlie, Charlie will only get the delegated balance of Bob, and will not be affected by the delegation Alice did. Delegation units are the same as balance units.","title":"Delegation in detail"},{"location":"user/delegation/delegation-in-detail/#check-pointing-historical-data","text":"Token data regarding vote power, delegation, balance and supply is all checkpointed to allow the retrieval of historical values. Per change in any value, a checkpoint is added to the array which includes the updated value and the block number. When trying to read historical data, a binary search is performed on the array. With this, the data retrieval cost grows on a logarithmic scale.","title":"Check pointing historical data"},{"location":"user/delegation/delegation-in-detail/#vote-power-data","text":"The above delegation scheme creates a mapping from balance to vote power for each address. The vote power of each address reflects its own balance plus any delegated vote power from other addresses. Vote power is never reused (double-spent): if vote power is delegated, the delegating address does not have this vote power under its own account.","title":"Vote power data"},{"location":"user/delegation/delegation-in-detail/#voting-campaigns-using-the-vote-power-token","text":"Checkpointed vote power data is used in voting campaigns (like FTSO reward epochs, for example). A voting campaign uses a randomly chosen block number from the past (vote power block). When an address (data provider) casts its vote for a specific campaign, its vote power is taken from the vote power block for this campaign. Hence, the vote power of an address for this campaign does not reflect its present balance and delegation but rather the state at the time of the snapshot (in the vote power block). This design allows for a free use of tokens (non-locked) and a consistent vote power snapshot of token holdings. Voting campaigns are a generic concept; in FTSO system, the vote power of price providers is used as an influence in choosing the final price. Each price submission is weighted according to the vote power scheme described here.","title":"Voting campaigns using the vote power token"},{"location":"user/delegation/delegation-in-detail/#revoke","text":"Due to the substantial length of time one past vote power block is used for price submissions, a revoke feature was added. This feature can be used in case any specific price provider is found trying to attack and skew the reported price of the FTSO (flare oracle). In this situation, an off chain process (e.g. twitter storm) calls users to revoke vote power from a specific price provider. The revoke will update the cached value of the vote power for the specific block which is being used for this reward epoch. So if a user revokes its vote power delegation on a specific block, checkpoints for the vote power will not be updated, only the cached vote power values are zeroed.","title":"Revoke"},{"location":"user/delegation/delegation-in-detail/#vote-power-block-selection","text":"The vote power of each price provider is cached and only recalculated at the start of each reward epoch. The selected vote power block (snapshot block) for a new epoch is selected randomly once the reward epoch starts. It is selected randomly with uniform probability from the last half (on Flare) or the last quarter (on Songbird) of mined blocks. This can roughly be approximated as taking the random block in the last half or quarter time-wise, but it is not necessarily correct , as block mining density can change.","title":"Vote power block selection"},{"location":"user/delegation/delegation-in-detail/#example-for-songbird","text":"Reward epoch with index 10 started at block 2487672 with timestamp 1637397708 (Saturday, November 20, 2021 8:41:48 AM GMT) and lasted until block 3003881 with timestamp 1638002503 (Saturday, November 27, 2021 8:41:43 AM GMT). This means that 516209 blocks were mined in this epoch and the last quarter of the blocks started with the block number 2487672 + 516209 * 3 / 4 = 2874828 with timestamp 1637817710 (Thursday, November 25, 2021 5:21:50 AM GMT). Any block between 2874828 and 3003881 is therefore eligible for selection as the vote power block. In this reward epoch, block 2881097 with timestamp 1637825442 (Thursday, November 25, 2021 7:30:42 AM GMT) was selected. This is before the last quarter of the week (Thursday, November 25, 2021 2:41:33 PM GMT) if we were to take the timestamp measure.","title":"Example for Songbird"},{"location":"user/delegation/delegation-in-detail/#developer-information","text":"","title":"Developer information"},{"location":"user/delegation/delegation-in-detail/#contracts","text":"The VPToken (Vote Power Token) is the base contract for wrapped tokens. This token contract is built to enable delegation of vote power without locking the holder\u2019s token. It works by adding the vote power and delegation functions to the ERC20 token contract. Basically, balance represents vote power; with the additional code, a holder can delegate a percentage of its own vote power to another address and still use their tokens freely. The transfer/mint/burn functions will immediately update the actual vote power being held by the delegator and the vote power of the address it delegates to. All vote power data is being checkpointed by block. For any vote power update due to delegation, transfer, or otherwise, a checkpoint is added. For anyone familiar with the MiniMe token , the checkpoint mechanism is similar, while differing in that more data is being checkpointed. When a voting campaign occurs, a past block will be randomly chosen and all vote power data will be taken from this block. This would actually work like taking a vote power snapshot for a specific block and using that for all addresses voting (providing prices) in the campaign. The random process of choosing a block is designed to mitigate attacks such as flash-loan or short term loans.","title":"Contracts"},{"location":"user/delegation/delegation-in-detail/#api","text":"ERC20 APIs. BalanceOfAt(address, block) , totalSupplyAt(block) as in MiniMe token. Delegation and vote power interfaces are described in IIVPToken interface file. Mint and burn APIs are handled in the inheriting contracts.","title":"API"},{"location":"user/delegation/delegation-in-detail/#caching","text":"Due to reward distribution constraints that are described in the FTSO reward manager specification, the same vote power block is used for a rather long period of time. This time frame, named \"reward epoch\", includes many short price epochs. Meaning, FTSO price feeds commencing over a period of a few days will continuously derive vote power from the same vote power block in the past. Usage of the same vote power block for many campaigns calls for a caching mechanism. The caching mechanism stores the vote power per address per block if done through a dedicated caching enabled function. For example, the normal vote power query function is votePowerOfAt(address, block) . This has a matching cache query: votePowerOfAtCache(address, block) which also caches the data on its first usage for a specific address and block. Later calls to both of these functions will use the cached value if it exists.","title":"Caching"},{"location":"user/delegation/delegation-in-detail/#retrieving-historical-data","text":"A large part of the native token inflation is distributed to participants in the FTSO price submission process. The reward won by a price provider is shared between the price provider and the vote power delegators to the price provider. The VP token exposes APIs that enable delegators to see how much vote power was delegated to a price provider in any past block. To enable this, the delegation percentage data are checkpointed after every change. Using the combination of delegation percentage and historical balance, each user can accurately see and show how much vote power they delegated to any address in the past. This API is also used by the reward manager, when the reward sharing is calculated. For explicit delegation, historical data is limited. It would be quite costly to continuously update a list of independent explicit delegations. That being said, when rewards are claimed for addresses that used explicit delegation, the delegator must already know which data providers it delegated vote power to in the relevant block. To recap, historical delegation APIs exist. For percentage delegations, each address can determine the full list of addresses it delegated to in any block in history. For explicit delegations, a user must use their own methods to build the list of addresses it delegated to at specific times. After building this list, one can query how much vote power was delegated to each address. Two options for building this list would be: Saving this data in real time while delegating. Reading past delegation events for this address.","title":"Retrieving historical data"},{"location":"user/delegation/manual-delegation/","text":"Manual delegation # This page explains how to delegate using a block explorer and Metamask. Caution This page is intended for advanced users who know how to interact with the blockchain through a block explorer. Congratulations on taking this more technical approach! It will enable you to better understand the system. How can I find the address of my chosen price provider? # Google 'Flare metrics' and in that website, chose a price provider. Find the Flare or Songbird address which should look something like 0xbf61db1cdb43d196309824473fa82e5b17581159 . Input that address in a block explorer . You should see that every few minutes it is submitting transactions named SubmitPriceHashes and RevealPrices . Where can I find the delegation API # The delegation API can be found in the WNAT contract, in function delegate . What values should I use in the delegation API? # The API for delegation is: delegate(_to address, bips) , where bips is the percentage in basis points. 10000 bips = 100% and 5000 bips = 50%. If one wants to delegate 100% of his vote power to the price provider in address: 0xbf61db1cdb43d196309824473fa82e5b17581159 the call should look like: delegate(0xbf61db1cdb43d196309824473fa82e5b1758115, 10000) . How do I remove my delegation from a price provider? # To remove a delegation you should delegate 0% to the price provider you want to remove delegations from. What is the easiest way to re-delegate my vote power? # It is probably easiest to first use the undelegateAll() API and then delegate to your chosen price provider/s.","title":"Manual delegation"},{"location":"user/delegation/manual-delegation/#manual-delegation","text":"This page explains how to delegate using a block explorer and Metamask. Caution This page is intended for advanced users who know how to interact with the blockchain through a block explorer. Congratulations on taking this more technical approach! It will enable you to better understand the system.","title":"Manual delegation"},{"location":"user/delegation/manual-delegation/#how-can-i-find-the-address-of-my-chosen-price-provider","text":"Google 'Flare metrics' and in that website, chose a price provider. Find the Flare or Songbird address which should look something like 0xbf61db1cdb43d196309824473fa82e5b17581159 . Input that address in a block explorer . You should see that every few minutes it is submitting transactions named SubmitPriceHashes and RevealPrices .","title":"How can I find the address of my chosen price provider?"},{"location":"user/delegation/manual-delegation/#where-can-i-find-the-delegation-api","text":"The delegation API can be found in the WNAT contract, in function delegate .","title":"Where can I find the delegation API"},{"location":"user/delegation/manual-delegation/#what-values-should-i-use-in-the-delegation-api","text":"The API for delegation is: delegate(_to address, bips) , where bips is the percentage in basis points. 10000 bips = 100% and 5000 bips = 50%. If one wants to delegate 100% of his vote power to the price provider in address: 0xbf61db1cdb43d196309824473fa82e5b17581159 the call should look like: delegate(0xbf61db1cdb43d196309824473fa82e5b1758115, 10000) .","title":"What values should I use in the delegation API?"},{"location":"user/delegation/manual-delegation/#how-do-i-remove-my-delegation-from-a-price-provider","text":"To remove a delegation you should delegate 0% to the price provider you want to remove delegations from.","title":"How do I remove my delegation from a price provider?"},{"location":"user/delegation/manual-delegation/#what-is-the-easiest-way-to-re-delegate-my-vote-power","text":"It is probably easiest to first use the undelegateAll() API and then delegate to your chosen price provider/s.","title":"What is the easiest way to re-delegate my vote power?"},{"location":"user/delegation/manual-reward-claiming/","text":"Manual reward claiming # This page explains how to claim your delegation rewards using a block explorer and Metamask. This is the continuation of the Manual delegation page. Caution This page is intended for advanced users who know how to interact with the blockchain through a block explorer. Where is the reward data found? # All reward data can be found in the FTSO Reward Manager. For which reward epochs can I claim rewards? # In the FTSO reward manager contract use the getEpochsWithUnclaimedRewards(beneficiary_address) method. What is the claim API? # API for claiming can be found in the FTSO Reward Manager, see method claimReward (_recipient address, _rewardEpochs uint256[]) . The address should be your address and reward epochs should include the list of epochs you want to claim rewards for. You may claim rewards for multiple epochs at one go. Where can I check the amount of rewards I have accrued in a reward epoch? # You can check the current amount of rewards (and unclaimed rewards) in the FtsoRewardManager method getStateOfRewards(beneficiery address, rewardEpoch) .","title":"Manual reward claiming"},{"location":"user/delegation/manual-reward-claiming/#manual-reward-claiming","text":"This page explains how to claim your delegation rewards using a block explorer and Metamask. This is the continuation of the Manual delegation page. Caution This page is intended for advanced users who know how to interact with the blockchain through a block explorer.","title":"Manual reward claiming"},{"location":"user/delegation/manual-reward-claiming/#where-is-the-reward-data-found","text":"All reward data can be found in the FTSO Reward Manager.","title":"Where is the reward data found?"},{"location":"user/delegation/manual-reward-claiming/#for-which-reward-epochs-can-i-claim-rewards","text":"In the FTSO reward manager contract use the getEpochsWithUnclaimedRewards(beneficiary_address) method.","title":"For which reward epochs can I claim rewards?"},{"location":"user/delegation/manual-reward-claiming/#what-is-the-claim-api","text":"API for claiming can be found in the FTSO Reward Manager, see method claimReward (_recipient address, _rewardEpochs uint256[]) . The address should be your address and reward epochs should include the list of epochs you want to claim rewards for. You may claim rewards for multiple epochs at one go.","title":"What is the claim API?"},{"location":"user/delegation/manual-reward-claiming/#where-can-i-check-the-amount-of-rewards-i-have-accrued-in-a-reward-epoch","text":"You can check the current amount of rewards (and unclaimed rewards) in the FtsoRewardManager method getStateOfRewards(beneficiery address, rewardEpoch) .","title":"Where can I check the amount of rewards I have accrued in a reward epoch?"},{"location":"user/delegation/reward-claiming-faq/","text":"Reward claiming FAQ # Am I eligible for rewards? # If you have delegated vote power in the snapshot block of a reward epoch, and this reward epoch was finalized, you should be eligible to claim some rewards. What contributes to the amount of reward one can claim? # This depends on a few factors: How much vote power was delegated and to which price providers. What was the performance of those price providers. How much fee do those price providers take. Was the total vote power of this price provider above the vote power cap. How do I see how much reward I can claim? # This depends on the wallet you are using. See wallets section to find more information and see the FAQ below for Metamask users. How do I claim my rewards? # See wallets section to find more information and see the FAQ below for Metamask users. When do I need to claim my rewards? # Rewards not claimed within 90 days will be re-allocated to the reward pool on Songbird and burnt on Flare. After claiming my rewards, how can I delegate the newly claimed tokens? # After you have successfully claimed your rewards, you receive native tokens ( $FLR or $SGB ). If you are delegating by percentage, once you wrap this to $WFLR or $WSGB your delegation will automatically be updated with the new balance, thus you do NOT need to change the delegation settings. How do I know if I have any rewards to claim? # As general guidance, if you wrapped your tokens, delegated your voting power and there was a vote power block and full reward epoch you should have rewards to claim, those should appear as your claimable rewards as seen in the relevant wallet you used for the delegation. Info Rewards can be claimed within 90 days so please remember to claim those within a reasonable time, or they will be lost. Also, remember to re-delegate to gain compound rewards. Where can I check the amount of rewards I have accrued in the current reward epoch? # You can check the current amount of rewards (and unclaimed rewards) using the FtsoRewardManager method ( getStateOfRewards ) or using your wallet. See wallets section to find details for specific wallets. How long do I have to wait to claim my rewards? # Rewards can be claimed after the end of each reward epoch (7 days on Songbird, 3.5 days on Flare). You need to wait for the full reward epoch in which you have delegated your vote power to be able to claim. Do I need to claim as fast as a reward epoch ends to maximize my earnings from delegations? # No. Claimed rewards cannot participate in the reward epoch they were claimed in. They can participate in the next reward epoch as long as they are wrapped roughly before the last half (on Flare) or the last quarter (on Songbird) of the current reward epoch (in terms of produced blocks). What is the Reward rate? # Reward rate is a metric of yield of data providers describing how many tokens were being earned by a data provider during a reward epoch for each delegated 100 tokens. It is calculated as total_reward / vote_power * (100 - fee) , where fee is given in percentages. What is a vote power cap and how does it influence my yields? # To facilitate decentralization of the network a share of vote power considered for rewarding is capped to 10% of all $WSGB in circulation (on Songbird) or to 2.5% of all $WFLR in circulation (on Flare). If a data provider gets more vote power through delegations, only a part of vote power (up to vote power cap) will compete for rewards while earned rewards will be distributed to all delegators, making the yield (reward rate) of the data provider lower.","title":"Reward claiming FAQ"},{"location":"user/delegation/reward-claiming-faq/#reward-claiming-faq","text":"","title":"Reward claiming FAQ"},{"location":"user/delegation/reward-claiming-faq/#am-i-eligible-for-rewards","text":"If you have delegated vote power in the snapshot block of a reward epoch, and this reward epoch was finalized, you should be eligible to claim some rewards.","title":"Am I eligible for rewards?"},{"location":"user/delegation/reward-claiming-faq/#what-contributes-to-the-amount-of-reward-one-can-claim","text":"This depends on a few factors: How much vote power was delegated and to which price providers. What was the performance of those price providers. How much fee do those price providers take. Was the total vote power of this price provider above the vote power cap.","title":"What contributes to the amount of reward one can claim?"},{"location":"user/delegation/reward-claiming-faq/#how-do-i-see-how-much-reward-i-can-claim","text":"This depends on the wallet you are using. See wallets section to find more information and see the FAQ below for Metamask users.","title":"How do I see how much reward I can claim?"},{"location":"user/delegation/reward-claiming-faq/#how-do-i-claim-my-rewards","text":"See wallets section to find more information and see the FAQ below for Metamask users.","title":"How do I claim my rewards?"},{"location":"user/delegation/reward-claiming-faq/#when-do-i-need-to-claim-my-rewards","text":"Rewards not claimed within 90 days will be re-allocated to the reward pool on Songbird and burnt on Flare.","title":"When do I need to claim my rewards?"},{"location":"user/delegation/reward-claiming-faq/#after-claiming-my-rewards-how-can-i-delegate-the-newly-claimed-tokens","text":"After you have successfully claimed your rewards, you receive native tokens ( $FLR or $SGB ). If you are delegating by percentage, once you wrap this to $WFLR or $WSGB your delegation will automatically be updated with the new balance, thus you do NOT need to change the delegation settings.","title":"After claiming my rewards, how can I delegate the newly claimed tokens?"},{"location":"user/delegation/reward-claiming-faq/#how-do-i-know-if-i-have-any-rewards-to-claim","text":"As general guidance, if you wrapped your tokens, delegated your voting power and there was a vote power block and full reward epoch you should have rewards to claim, those should appear as your claimable rewards as seen in the relevant wallet you used for the delegation. Info Rewards can be claimed within 90 days so please remember to claim those within a reasonable time, or they will be lost. Also, remember to re-delegate to gain compound rewards.","title":"How do I know if I have any rewards to claim?"},{"location":"user/delegation/reward-claiming-faq/#where-can-i-check-the-amount-of-rewards-i-have-accrued-in-the-current-reward-epoch","text":"You can check the current amount of rewards (and unclaimed rewards) using the FtsoRewardManager method ( getStateOfRewards ) or using your wallet. See wallets section to find details for specific wallets.","title":"Where can I check the amount of rewards I have accrued in the current reward epoch?"},{"location":"user/delegation/reward-claiming-faq/#how-long-do-i-have-to-wait-to-claim-my-rewards","text":"Rewards can be claimed after the end of each reward epoch (7 days on Songbird, 3.5 days on Flare). You need to wait for the full reward epoch in which you have delegated your vote power to be able to claim.","title":"How long do I have to wait to claim my rewards?"},{"location":"user/delegation/reward-claiming-faq/#do-i-need-to-claim-as-fast-as-a-reward-epoch-ends-to-maximize-my-earnings-from-delegations","text":"No. Claimed rewards cannot participate in the reward epoch they were claimed in. They can participate in the next reward epoch as long as they are wrapped roughly before the last half (on Flare) or the last quarter (on Songbird) of the current reward epoch (in terms of produced blocks).","title":"Do I need to claim as fast as a reward epoch ends to maximize my earnings from delegations?"},{"location":"user/delegation/reward-claiming-faq/#what-is-the-reward-rate","text":"Reward rate is a metric of yield of data providers describing how many tokens were being earned by a data provider during a reward epoch for each delegated 100 tokens. It is calculated as total_reward / vote_power * (100 - fee) , where fee is given in percentages.","title":"What is the Reward rate?"},{"location":"user/delegation/reward-claiming-faq/#what-is-a-vote-power-cap-and-how-does-it-influence-my-yields","text":"To facilitate decentralization of the network a share of vote power considered for rewarding is capped to 10% of all $WSGB in circulation (on Songbird) or to 2.5% of all $WFLR in circulation (on Flare). If a data provider gets more vote power through delegations, only a part of vote power (up to vote power cap) will compete for rewards while earned rewards will be distributed to all delegators, making the yield (reward rate) of the data provider lower.","title":"What is a vote power cap and how does it influence my yields?"},{"location":"user/delegation/reward-claiming-in-detail/","text":"Reward claiming in detail # Attention This page is intended for developers. FTSO Rewards # During the FTSO price voting process, rewards are being distributed to data providers based on their vote power. Depending on the vote power share and price provider fee percentage, a part of this reward belongs to users who have delegated their $WFLR or $WSGB vote power to the price providers. The rewards can be claimed via the contract FtsoRewardManager that implements IFtsoRewardManager interface as described in this document. Reward claiming # The reward claiming process depends on vote power delegation mode. The default delegation mode is delegation by percentage. Delegation by amount is intended for advanced users. The delegation mode of a user can be checked by calling delegationModeOf on the WNAT contract that implements the IVPToken interface. Delegation by percentage # The user that has delegated vote power by percentage can claim rewards by calling the function claimReward with the following signature. function claimReward ( address payable _recipient , uint256 [] memory _rewardEpochs ) external returns ( uint256 _rewardAmount ) Parameters: _recipient : The address to which the reward is transferred (can be different from the calling address). _rewardEpochs : The list of reward epoch IDs for which the reward is being claimed. _rewardAmount : The amount of claimed rewards that is transferred to _recipient . The amount is the sum of all rewards that the caller ( msg.sender ) is entitled to in the specified _rewardEpochs (i.e., it includes the unclaimed rewards for all price providers the user has delegated to). Note that this function throws an exception if it is called by a user ( msg.sender ) that is delegating by amount. To specify an appropriate input array _rewardEpochs , the function getEpochsWithUnclaimedRewards can be used. It iterates over the past reward epochs that still enable reward claiming and gathers the IDs of those, for which the reward allocated to _beneficiary has not yet been (fully) claimed. function getEpochsWithUnclaimedRewards ( address _beneficiary ) external view override returns ( uint256 [] memory _epochIds ) To obtain more detailed information on reward status, its origin and amount, a user can use the functions getStateOfRewards or getStateOfRewardsFromDataProviders described later in this page. A user that is delegating by percentage can also use the function claimRewardFromDataProviders (described in the following section) to claim the rewards only for specific price providers (e.g., if the user wishes to have rewards from different price providers transferred to different recipient addresses). However, the gas consumption for calling claimRewardFromDataProviders higher. Delegation by amount # A user delegating vote power by amount can claim rewards by calling the function claimRewardFromDataProviders with the following signature. function claimRewardFromDataProviders ( address payable _recipient , uint256 [] memory _rewardEpochs , address [] memory _dataProviders ) external returns ( uint256 _rewardAmount ) Parameters: _recipient : The address to which the reward is transferred (can be different from the calling address). _rewardEpochs : The list of reward epoch IDs for which the reward is being claimed. _dataProviders : The list of addresses corresponding to price providers. _rewardAmount : The amount of claimed rewards that is transferred to _recipient . The amount is the sum of all rewards that the caller ( msg.sender ) is entitled to in the specified _rewardEpochs (i.e., it includes the unclaimed rewards for all price providers specified in _dataProviders ). The main difference in comparison to claimReward is that claimRewardFromDataProviders requires a user to specify the array _dataProviders containing the addresses of price providers that the user has delegated the vote power to. To prepare the input array _rewardEpochs , a user that is delegating by amount cannot use the function getEpochsWithUnclaimedRewards (a request fails with exception). Instead, the function getEpochsWithClaimableRewards can be called to get the information on the reward epochs for which the reward is still claimable, and getStateOfRewardsFromDataProvider to obtain details about the state of rewards in a specific (claimable) reward epoch. Below is a code snippet describing this procedure. The functions and their parameters are in more detail explained in the subsequent sections. ( startEpochId , endEpochId ) = getEpochsWithUnclaimedRewards (); for ( uint256 epochId = startEpochId ; epochId <= endEpochId ; epochId ++ ) { (...) = getStateOfRewardsFromDataProviders (..., epochId , ...); } Events # For every call to claimReward or claimRewardFromDataProviders one or more events of the following type are issued. A specific event is associated with a single pair of price provider and reward epoch. event RewardClaimed ( address indexed dataProvider , address indexed whoClaimed , address indexed sentTo , uint256 rewardEpoch , uint256 amount ) Parameters: dataProvider : The address to which the reward was allocated. whoClaimed : The address from which the reward claim was initiated. sentTo : The address to which the amount was sent. rewardEpoch : The ID of the reward epoch the claimed reward corresponds to. amount : The value of the claimed reward. Reward claim expiration # The reward can be claimed from the time the reward was allocated until the reward expiry epoch. The oldest and the newest reward epoch that allow reward claiming can be obtained by calling getEpochsWithClaimableRewards (these correspond to the return values _startEpochId and _endEpochId , respectively). function getEpochsWithClaimableRewards () external view returns ( uint256 _startEpochId , uint256 _endEpochId ) The reward expiry epoch is also communicated through RewardClaimsExpired event. event RewardClaimsExpired ( uint256 rewardEpochId ) The information for which epochs the rewards have been already claimed can be obtained by checking the state of rewards described in the following section. Reward amount in depth # Overview # Suppose a total reward amount REWARD is allocated to a price provider P for a reward epoch E . This reward is divided among P and users who delegated to P depending on the WSGB vote power share and P 's fee percentage. Let PVP be the total WSGB vote power associated with P . This is the sum of P 's own undelegated WSGB vote power and the WSGB vote powers that have been delegated to P . The vote power snapshot is used, which corresponds to a specific block before the start of E (vote power block). Suppose SHARE is the vote power share: for P this is the ratio between P 's own undelegated WNat vote power and PVP , for delegator this is the ratio between the WNat vote power that the delegator has delegated to P and PVP . Suppose FP denotes P 's fee percentage for E . Then P is entitled to the reward equal to (SHARE * (1 - FP) * REWARD) + (FP * REWARD) , and a delegator is entitled to the amount equal to SHARE * (1 - FP) * REWARD . State of rewards # The reward amounts for a specific address can be checked by calling either getStateOfRewards or getStateOfRewardsFromDataProviders . The difference between these two functions is that in the first the array of price providers (to which the reward is initially allocated) is obtained based on delegation history, while in the second the array has to be specified as an input parameter. Note that getStateOfRewards can only be used for addresses that are declared to be delegating by percentage. function getStateOfRewards ( address _beneficiary , uint256 _rewardEpoch ) external view returns ( address [] memory _dataProviders , uint256 [] memory _rewardAmounts , bool [] memory _claimed , bool _claimable ) function getStateOfRewardsFromDataProviders ( address _beneficiary , uint256 _rewardEpoch , address [] memory _dataProviders ) external view returns ( uint256 [] memory _rewardAmounts , bool [] memory _claimed , bool _claimable ) Parameters: _beneficiary : The address for which the state is being checked. _rewardEpoch : The id of the reward epoch for which the state is being checked. _dataProviders : The positional array of addresses representing the price providers the rewards have been allocated to. _rewardAmounts : The positional array of values representing the reward amounts the _beneficiary is entitled to. _claimed : The positional array of boolean values indicating if the reward amount has already been claimed. _claimable : The boolean value indicating if the reward amounts are claimable (i.e., are available and have not expired). Note that the amounts reported by these two methods are informational and can slightly differ from the actual amounts obtained via claimReward and claimRewardFromDataProviders due to rounding. Reward fee # Current fee percentage # Price provider fee is determined by fee percentage. Current setting can be obtained by getDataProviderCurrentFeePercentage . function getDataProviderCurrentFeePercentage ( address _dataProvider ) external view returns ( uint256 _feePercentageBIPS ) The value _feePercentageBIPS is given in basis points (BIPS), which is a percentage value multiplied by 100 (e.g., 10% fee is 1000). Scheduled fee percentage changes # The fee percentage is subject to changes. The changes made by price providers are time locked, meaning they are scheduled for some future time. Scheduled changes can be checked by calling getDataProviderScheduledFeePercentageChanges , which returns the fee percentages in the future. function getDataProviderScheduledFeePercentageChanges ( address _dataProvider ) external view returns ( uint256 [] memory _feePercentageBIPS , uint256 [] memory _validFromEpoch , bool [] memory _fixed ) Parameters: _dataProvder : The address representing a price provider. _feePercentageBIPS : The positional array of scheduled fee percentages in BIPS. validFromEpoch : The positional array of future reward epoch ids from which the value _feePercentageBIPS will be effective. _fixed : The positional array of boolean values indicating if the setting is fixed. If the scheduled fee percentage is not fixed, this means that it can still be updated by price provider over the course of the current reward epoch. After the current reward epoch passes, the setting becomes fixed.","title":"Reward claiming in detail"},{"location":"user/delegation/reward-claiming-in-detail/#reward-claiming-in-detail","text":"Attention This page is intended for developers.","title":"Reward claiming in detail"},{"location":"user/delegation/reward-claiming-in-detail/#ftso-rewards","text":"During the FTSO price voting process, rewards are being distributed to data providers based on their vote power. Depending on the vote power share and price provider fee percentage, a part of this reward belongs to users who have delegated their $WFLR or $WSGB vote power to the price providers. The rewards can be claimed via the contract FtsoRewardManager that implements IFtsoRewardManager interface as described in this document.","title":"FTSO Rewards"},{"location":"user/delegation/reward-claiming-in-detail/#reward-claiming","text":"The reward claiming process depends on vote power delegation mode. The default delegation mode is delegation by percentage. Delegation by amount is intended for advanced users. The delegation mode of a user can be checked by calling delegationModeOf on the WNAT contract that implements the IVPToken interface.","title":"Reward claiming"},{"location":"user/delegation/reward-claiming-in-detail/#delegation-by-percentage","text":"The user that has delegated vote power by percentage can claim rewards by calling the function claimReward with the following signature. function claimReward ( address payable _recipient , uint256 [] memory _rewardEpochs ) external returns ( uint256 _rewardAmount ) Parameters: _recipient : The address to which the reward is transferred (can be different from the calling address). _rewardEpochs : The list of reward epoch IDs for which the reward is being claimed. _rewardAmount : The amount of claimed rewards that is transferred to _recipient . The amount is the sum of all rewards that the caller ( msg.sender ) is entitled to in the specified _rewardEpochs (i.e., it includes the unclaimed rewards for all price providers the user has delegated to). Note that this function throws an exception if it is called by a user ( msg.sender ) that is delegating by amount. To specify an appropriate input array _rewardEpochs , the function getEpochsWithUnclaimedRewards can be used. It iterates over the past reward epochs that still enable reward claiming and gathers the IDs of those, for which the reward allocated to _beneficiary has not yet been (fully) claimed. function getEpochsWithUnclaimedRewards ( address _beneficiary ) external view override returns ( uint256 [] memory _epochIds ) To obtain more detailed information on reward status, its origin and amount, a user can use the functions getStateOfRewards or getStateOfRewardsFromDataProviders described later in this page. A user that is delegating by percentage can also use the function claimRewardFromDataProviders (described in the following section) to claim the rewards only for specific price providers (e.g., if the user wishes to have rewards from different price providers transferred to different recipient addresses). However, the gas consumption for calling claimRewardFromDataProviders higher.","title":"Delegation by percentage"},{"location":"user/delegation/reward-claiming-in-detail/#delegation-by-amount","text":"A user delegating vote power by amount can claim rewards by calling the function claimRewardFromDataProviders with the following signature. function claimRewardFromDataProviders ( address payable _recipient , uint256 [] memory _rewardEpochs , address [] memory _dataProviders ) external returns ( uint256 _rewardAmount ) Parameters: _recipient : The address to which the reward is transferred (can be different from the calling address). _rewardEpochs : The list of reward epoch IDs for which the reward is being claimed. _dataProviders : The list of addresses corresponding to price providers. _rewardAmount : The amount of claimed rewards that is transferred to _recipient . The amount is the sum of all rewards that the caller ( msg.sender ) is entitled to in the specified _rewardEpochs (i.e., it includes the unclaimed rewards for all price providers specified in _dataProviders ). The main difference in comparison to claimReward is that claimRewardFromDataProviders requires a user to specify the array _dataProviders containing the addresses of price providers that the user has delegated the vote power to. To prepare the input array _rewardEpochs , a user that is delegating by amount cannot use the function getEpochsWithUnclaimedRewards (a request fails with exception). Instead, the function getEpochsWithClaimableRewards can be called to get the information on the reward epochs for which the reward is still claimable, and getStateOfRewardsFromDataProvider to obtain details about the state of rewards in a specific (claimable) reward epoch. Below is a code snippet describing this procedure. The functions and their parameters are in more detail explained in the subsequent sections. ( startEpochId , endEpochId ) = getEpochsWithUnclaimedRewards (); for ( uint256 epochId = startEpochId ; epochId <= endEpochId ; epochId ++ ) { (...) = getStateOfRewardsFromDataProviders (..., epochId , ...); }","title":"Delegation by amount"},{"location":"user/delegation/reward-claiming-in-detail/#events","text":"For every call to claimReward or claimRewardFromDataProviders one or more events of the following type are issued. A specific event is associated with a single pair of price provider and reward epoch. event RewardClaimed ( address indexed dataProvider , address indexed whoClaimed , address indexed sentTo , uint256 rewardEpoch , uint256 amount ) Parameters: dataProvider : The address to which the reward was allocated. whoClaimed : The address from which the reward claim was initiated. sentTo : The address to which the amount was sent. rewardEpoch : The ID of the reward epoch the claimed reward corresponds to. amount : The value of the claimed reward.","title":"Events"},{"location":"user/delegation/reward-claiming-in-detail/#reward-claim-expiration","text":"The reward can be claimed from the time the reward was allocated until the reward expiry epoch. The oldest and the newest reward epoch that allow reward claiming can be obtained by calling getEpochsWithClaimableRewards (these correspond to the return values _startEpochId and _endEpochId , respectively). function getEpochsWithClaimableRewards () external view returns ( uint256 _startEpochId , uint256 _endEpochId ) The reward expiry epoch is also communicated through RewardClaimsExpired event. event RewardClaimsExpired ( uint256 rewardEpochId ) The information for which epochs the rewards have been already claimed can be obtained by checking the state of rewards described in the following section.","title":"Reward claim expiration"},{"location":"user/delegation/reward-claiming-in-detail/#reward-amount-in-depth","text":"","title":"Reward amount in depth"},{"location":"user/delegation/reward-claiming-in-detail/#overview","text":"Suppose a total reward amount REWARD is allocated to a price provider P for a reward epoch E . This reward is divided among P and users who delegated to P depending on the WSGB vote power share and P 's fee percentage. Let PVP be the total WSGB vote power associated with P . This is the sum of P 's own undelegated WSGB vote power and the WSGB vote powers that have been delegated to P . The vote power snapshot is used, which corresponds to a specific block before the start of E (vote power block). Suppose SHARE is the vote power share: for P this is the ratio between P 's own undelegated WNat vote power and PVP , for delegator this is the ratio between the WNat vote power that the delegator has delegated to P and PVP . Suppose FP denotes P 's fee percentage for E . Then P is entitled to the reward equal to (SHARE * (1 - FP) * REWARD) + (FP * REWARD) , and a delegator is entitled to the amount equal to SHARE * (1 - FP) * REWARD .","title":"Overview"},{"location":"user/delegation/reward-claiming-in-detail/#state-of-rewards","text":"The reward amounts for a specific address can be checked by calling either getStateOfRewards or getStateOfRewardsFromDataProviders . The difference between these two functions is that in the first the array of price providers (to which the reward is initially allocated) is obtained based on delegation history, while in the second the array has to be specified as an input parameter. Note that getStateOfRewards can only be used for addresses that are declared to be delegating by percentage. function getStateOfRewards ( address _beneficiary , uint256 _rewardEpoch ) external view returns ( address [] memory _dataProviders , uint256 [] memory _rewardAmounts , bool [] memory _claimed , bool _claimable ) function getStateOfRewardsFromDataProviders ( address _beneficiary , uint256 _rewardEpoch , address [] memory _dataProviders ) external view returns ( uint256 [] memory _rewardAmounts , bool [] memory _claimed , bool _claimable ) Parameters: _beneficiary : The address for which the state is being checked. _rewardEpoch : The id of the reward epoch for which the state is being checked. _dataProviders : The positional array of addresses representing the price providers the rewards have been allocated to. _rewardAmounts : The positional array of values representing the reward amounts the _beneficiary is entitled to. _claimed : The positional array of boolean values indicating if the reward amount has already been claimed. _claimable : The boolean value indicating if the reward amounts are claimable (i.e., are available and have not expired). Note that the amounts reported by these two methods are informational and can slightly differ from the actual amounts obtained via claimReward and claimRewardFromDataProviders due to rounding.","title":"State of rewards"},{"location":"user/delegation/reward-claiming-in-detail/#reward-fee","text":"","title":"Reward fee"},{"location":"user/delegation/reward-claiming-in-detail/#current-fee-percentage","text":"Price provider fee is determined by fee percentage. Current setting can be obtained by getDataProviderCurrentFeePercentage . function getDataProviderCurrentFeePercentage ( address _dataProvider ) external view returns ( uint256 _feePercentageBIPS ) The value _feePercentageBIPS is given in basis points (BIPS), which is a percentage value multiplied by 100 (e.g., 10% fee is 1000).","title":"Current fee percentage"},{"location":"user/delegation/reward-claiming-in-detail/#scheduled-fee-percentage-changes","text":"The fee percentage is subject to changes. The changes made by price providers are time locked, meaning they are scheduled for some future time. Scheduled changes can be checked by calling getDataProviderScheduledFeePercentageChanges , which returns the fee percentages in the future. function getDataProviderScheduledFeePercentageChanges ( address _dataProvider ) external view returns ( uint256 [] memory _feePercentageBIPS , uint256 [] memory _validFromEpoch , bool [] memory _fixed ) Parameters: _dataProvder : The address representing a price provider. _feePercentageBIPS : The positional array of scheduled fee percentages in BIPS. validFromEpoch : The positional array of future reward epoch ids from which the value _feePercentageBIPS will be effective. _fixed : The positional array of boolean values indicating if the setting is fixed. If the scheduled fee percentage is not fixed, this means that it can still be updated by price provider over the course of the current reward epoch. After the current reward epoch passes, the setting becomes fixed.","title":"Scheduled fee percentage changes"},{"location":"user/delegation/reward-claiming/","text":"Reward claiming overview # Each user delegating its vote power to an active price provider can earn rewards. The rewards are accumulated through the course of reward epochs, 7-days long on Songbird and 3.5-days long on Flare. Once each reward epoch finalizes, the user can claim the rewards that were earned during this reward epoch. The rewards are accumulated in the FtsoRewardManager contract and expire after 90 days. The claim operation costs some gas, paid in $FLR or $SGB , and can be done for one reward epoch or a list of a few epochs at once. The reward system distributes a large part of the yearly inflation to participants of the FTSO system. This could be seen as the mining process for the Flare chains. During the first years of Flare's and Songbird's existence, most of the yearly inflation will be distributed to participants of the FTSO system. The distribution works such that the yearly inflation is divided into daily portions. That daily portion is split between all price epochs happening that day. The FTSO system includes price feeds for USD prices of a few assets, Ex: BTC/USD, XRP/USD etc. Per price epoch one FTSO price feed is chosen to be rewarded. The reward is split between the addresses which submitted the most accurate prices. Reward flow: Per price epoch all price feeds to an FTSO are being used to calculate a weighted median. The weighted median is the chosen price of this FTSO (time series). Next, a percentage of the addresses on each side of the weighted median are chosen to be rewarded. Each address is rewarded according to its weight (vote power). The reward data is sent to the FtsoRewardManager smart contract. Once the reward epoch is finalized, this reward can be claimed from the FtsoRewardManager . Each price provider receives rewards according to its vote power. Those rewards can be claimed by the price provider and anyone who delegated its vote power to this price provider during this reward epoch.","title":"Reward claiming overview"},{"location":"user/delegation/reward-claiming/#reward-claiming-overview","text":"Each user delegating its vote power to an active price provider can earn rewards. The rewards are accumulated through the course of reward epochs, 7-days long on Songbird and 3.5-days long on Flare. Once each reward epoch finalizes, the user can claim the rewards that were earned during this reward epoch. The rewards are accumulated in the FtsoRewardManager contract and expire after 90 days. The claim operation costs some gas, paid in $FLR or $SGB , and can be done for one reward epoch or a list of a few epochs at once. The reward system distributes a large part of the yearly inflation to participants of the FTSO system. This could be seen as the mining process for the Flare chains. During the first years of Flare's and Songbird's existence, most of the yearly inflation will be distributed to participants of the FTSO system. The distribution works such that the yearly inflation is divided into daily portions. That daily portion is split between all price epochs happening that day. The FTSO system includes price feeds for USD prices of a few assets, Ex: BTC/USD, XRP/USD etc. Per price epoch one FTSO price feed is chosen to be rewarded. The reward is split between the addresses which submitted the most accurate prices. Reward flow: Per price epoch all price feeds to an FTSO are being used to calculate a weighted median. The weighted median is the chosen price of this FTSO (time series). Next, a percentage of the addresses on each side of the weighted median are chosen to be rewarded. Each address is rewarded according to its weight (vote power). The reward data is sent to the FtsoRewardManager smart contract. Once the reward epoch is finalized, this reward can be claimed from the FtsoRewardManager . Each price provider receives rewards according to its vote power. Those rewards can be claimed by the price provider and anyone who delegated its vote power to this price provider during this reward epoch.","title":"Reward claiming overview"},{"location":"user/wallets/","text":"Wallets # Choose your wallet from the navigation menu.","title":"Wallets"},{"location":"user/wallets/#wallets","text":"Choose your wallet from the navigation menu.","title":"Wallets"},{"location":"user/wallets/bifrost-wallet/","text":"Bifrost Wallet # Bifrost Wallet is a non-custodial mobile wallet available for both Android and iOS. You can view your portfolio of crypto assets, access decentralized applications through the in-app browser and perform operations on various blockchain networks, including sending, receiving, wrapping and delegating Flare ( $FLR ) and Songbird ( $SGB ). Getting Started # Start by downloading Bifrost Wallet from the Apple App Store or Google Play Store and either create a new wallet or import an existing one from a recovery phrase. The official guides in the Bifrost Wallet help center may be of assistance. Please make sure you have installed at least version 0.4.5 XRP Airdrop Note that, once $FLR distribution begins , users who imported their Ethereum-style claim address into Bifrost to access the XRP airdrop will automatically see their tokens in the Flare asset row in the COINS section. Wrap and Delegate # To wrap and delegate your $SGB or $FLR tokens using Bifrost Wallet, see the official guide (works for both Songbird and Flare) or follow the steps outlined below: Songbird Flare Open the Bifrost app and create or restore a wallet. Click on the Songbird asset row on the home screen (visible once you hold some $SGB ). Click the 3 horizontal dots on the upper right-hand side of the screen, and click Wrap . Select the amount of $SGB you wish to wrap and click Continue . Click Confirm and then Close . Select the back arrow in the upper left-hand corner of the screen. You will now see a second asset row on your home screen for Wrapped Songbird ( $WSGB ). Click on the Wrapped Songbird asset row. Click the 3 horizontal dots on the upper right-hand side of the screen and click Delegate . Click the Add Provider tab toward the bottom of the screen. Select which provider you want to delegate to (you can select up to 2 providers). Choose the percentage of your $WSGB you wish to delegate to that specific provider. Click Continue then click Confirm and finally click Close . Repeat steps 10 to 13 if you wish to delegate to a second provider. Open the Bifrost app and create or restore a wallet. Click on the Flare asset row on the home screen (visible once you hold some $FLR ). Click the 3 horizontal dots on the upper right-hand side of the screen, and click Wrap . Select the amount of $FLR you wish to wrap and click Continue . Click Confirm and then Close . Select the back arrow in the upper left-hand corner of the screen. You will now see a second asset row on your home screen for Wrapped Flare ( $WFLR ). Click on the Wrapped Flare asset row. Click the 3 horizontal dots on the upper right-hand side of the screen and click Delegate . Click the Add Provider tab toward the bottom of the screen. Select which provider you want to delegate to (you can select up to 2 providers). Choose the percentage of your $WFLR you wish to delegate to that specific provider. Click Continue then click Confirm and finally click Close . Repeat steps 10 to 13 if you wish to delegate to a second provider.","title":"Bifrost Wallet"},{"location":"user/wallets/bifrost-wallet/#bifrost-wallet","text":"Bifrost Wallet is a non-custodial mobile wallet available for both Android and iOS. You can view your portfolio of crypto assets, access decentralized applications through the in-app browser and perform operations on various blockchain networks, including sending, receiving, wrapping and delegating Flare ( $FLR ) and Songbird ( $SGB ).","title":"Bifrost Wallet"},{"location":"user/wallets/bifrost-wallet/#getting-started","text":"Start by downloading Bifrost Wallet from the Apple App Store or Google Play Store and either create a new wallet or import an existing one from a recovery phrase. The official guides in the Bifrost Wallet help center may be of assistance. Please make sure you have installed at least version 0.4.5 XRP Airdrop Note that, once $FLR distribution begins , users who imported their Ethereum-style claim address into Bifrost to access the XRP airdrop will automatically see their tokens in the Flare asset row in the COINS section.","title":"Getting Started"},{"location":"user/wallets/bifrost-wallet/#wrap-and-delegate","text":"To wrap and delegate your $SGB or $FLR tokens using Bifrost Wallet, see the official guide (works for both Songbird and Flare) or follow the steps outlined below: Songbird Flare Open the Bifrost app and create or restore a wallet. Click on the Songbird asset row on the home screen (visible once you hold some $SGB ). Click the 3 horizontal dots on the upper right-hand side of the screen, and click Wrap . Select the amount of $SGB you wish to wrap and click Continue . Click Confirm and then Close . Select the back arrow in the upper left-hand corner of the screen. You will now see a second asset row on your home screen for Wrapped Songbird ( $WSGB ). Click on the Wrapped Songbird asset row. Click the 3 horizontal dots on the upper right-hand side of the screen and click Delegate . Click the Add Provider tab toward the bottom of the screen. Select which provider you want to delegate to (you can select up to 2 providers). Choose the percentage of your $WSGB you wish to delegate to that specific provider. Click Continue then click Confirm and finally click Close . Repeat steps 10 to 13 if you wish to delegate to a second provider. Open the Bifrost app and create or restore a wallet. Click on the Flare asset row on the home screen (visible once you hold some $FLR ). Click the 3 horizontal dots on the upper right-hand side of the screen, and click Wrap . Select the amount of $FLR you wish to wrap and click Continue . Click Confirm and then Close . Select the back arrow in the upper left-hand corner of the screen. You will now see a second asset row on your home screen for Wrapped Flare ( $WFLR ). Click on the Wrapped Flare asset row. Click the 3 horizontal dots on the upper right-hand side of the screen and click Delegate . Click the Add Provider tab toward the bottom of the screen. Select which provider you want to delegate to (you can select up to 2 providers). Choose the percentage of your $WFLR you wish to delegate to that specific provider. Click Continue then click Confirm and finally click Close . Repeat steps 10 to 13 if you wish to delegate to a second provider.","title":"Wrap and Delegate"},{"location":"user/wallets/brave-wallet/","text":"Brave Wallet # Brave Browser now offers a non-custodial software wallet on both Windows and macOS for Ethereum Virtual Machine (EVM) integrated chains such as Songbird and Flare. Getting Started # To use Brave Wallet with Songbird or Flare, first make sure that you have: Downloaded Brave Browser to your computer, version 1.42.88 or later. Initialized a Brave wallet or restored an existing one. Protected your Brave wallet with a password. Backed up your crypto wallet with a 12-word recovery phrase. Once your wallet is set up, you will need to connect to one of Flare's networks. This involves adding a custom network via the following steps: Open Brave Browser on your computer. Navigate to settings and select Wallet from the list of options. In the box on the right click Networks , then Add . Input the following information in the appropriate fields: Songbird Flare Field Value The id of new chain 19 Enter name of new chain Songbird Chain's currency name Songbird Chain's currency symbol SGB Chain\u2019s currency decimals 18 RPC URLs https://songbird-api.flare.network/ext/C/rpc Icon URLs_ (leave blank) Block Explorer URLs https://songbird-explorer.flare.network Field Value The id of new chain 14 Enter name of new chain Flare Chain's currency name Flare Chain's currency symbol FLR Chain\u2019s currency decimals 18 RPC URLs https://flare-api.flare.network/ext/C/rpc Icon URLs_ (leave blank) Block Explorer URLs https://flare-explorer.flare.network Finally, click Submit . To finish connecting: Enter your password and login to your wallet. On the left of the screen next to Balance click the drop-down menu and select Songbird or Flare. Connection is now complete. Wrap and Delegate # Brave users can access existing decentralized applications (dApps) created by independent organizations to wrap and delegate their SGB and FLR tokens, via the following steps ( Read more about delegation ): Open Brave Browser and login to your wallet (make sure you are connected to Songbird or Flare). Open a second search tab within Brave. Enter the address of the website or dApp you wish to use to wrap and delegate in the search bar at the top of the screen. Info These dApps are usually created by FTSO data providers , but some of them allow you to choose a different data provider to delegate to. Take a look at flaremetrics.io and pick the one you prefer. Follow the prompts to connect your Brave wallet and sign transactions when wrapping, delegating, or claiming rewards. See the full list of data providers on Songbird at flaremetrics.io .","title":"Brave Wallet"},{"location":"user/wallets/brave-wallet/#brave-wallet","text":"Brave Browser now offers a non-custodial software wallet on both Windows and macOS for Ethereum Virtual Machine (EVM) integrated chains such as Songbird and Flare.","title":"Brave Wallet"},{"location":"user/wallets/brave-wallet/#getting-started","text":"To use Brave Wallet with Songbird or Flare, first make sure that you have: Downloaded Brave Browser to your computer, version 1.42.88 or later. Initialized a Brave wallet or restored an existing one. Protected your Brave wallet with a password. Backed up your crypto wallet with a 12-word recovery phrase. Once your wallet is set up, you will need to connect to one of Flare's networks. This involves adding a custom network via the following steps: Open Brave Browser on your computer. Navigate to settings and select Wallet from the list of options. In the box on the right click Networks , then Add . Input the following information in the appropriate fields: Songbird Flare Field Value The id of new chain 19 Enter name of new chain Songbird Chain's currency name Songbird Chain's currency symbol SGB Chain\u2019s currency decimals 18 RPC URLs https://songbird-api.flare.network/ext/C/rpc Icon URLs_ (leave blank) Block Explorer URLs https://songbird-explorer.flare.network Field Value The id of new chain 14 Enter name of new chain Flare Chain's currency name Flare Chain's currency symbol FLR Chain\u2019s currency decimals 18 RPC URLs https://flare-api.flare.network/ext/C/rpc Icon URLs_ (leave blank) Block Explorer URLs https://flare-explorer.flare.network Finally, click Submit . To finish connecting: Enter your password and login to your wallet. On the left of the screen next to Balance click the drop-down menu and select Songbird or Flare. Connection is now complete.","title":"Getting Started"},{"location":"user/wallets/brave-wallet/#wrap-and-delegate","text":"Brave users can access existing decentralized applications (dApps) created by independent organizations to wrap and delegate their SGB and FLR tokens, via the following steps ( Read more about delegation ): Open Brave Browser and login to your wallet (make sure you are connected to Songbird or Flare). Open a second search tab within Brave. Enter the address of the website or dApp you wish to use to wrap and delegate in the search bar at the top of the screen. Info These dApps are usually created by FTSO data providers , but some of them allow you to choose a different data provider to delegate to. Take a look at flaremetrics.io and pick the one you prefer. Follow the prompts to connect your Brave wallet and sign transactions when wrapping, delegating, or claiming rewards. See the full list of data providers on Songbird at flaremetrics.io .","title":"Wrap and Delegate"},{"location":"user/wallets/dcent-wallet/","text":"D'CENT Wallet # D'CENT Biometric Wallet is a non-custodial hardware wallet and is considered one of the most secure ways to manage your crypto assets. Getting Started # Purchase a D'CENT Biometric hardware wallet from the official D'CENT shop or download their software wallet/mobile app from the Apple App Store or Google Play Store . Then either initialize a new wallet or import an existing one from a recovery phrase. The official D'cent device setup help guides can be found here: https://userguide.dcentwallet.com/biometric-wallet/setting-up . Once your device is set up and synced with the mobile app you will need to add $FLR and $SGB to your listed assets: Ensure the D'cent biometric wallet is updated with the latest firmware, v2.24.0 or later. Login to your D'cent mobile app and have your device turned on, unlocked, and paired via Bluetooth. Click the + sign on the bottom right of the Account tab. Search for \"Flare\" or \"Songbird\" in the search box. Select the Flare Token (FLR) or Songbird Token (SGB) . Name your new account and click Create . Repeat for the other token. You should also add the wrapped versions of the tokens ( $WFLR and $WSGB ) to the listed assets: With your device unlocked and paired, click the + sign on the bottom right of the Account tab. Search for \"Wrapped Flare\" or \"Wrapped Songbird\" in the search box. Select the wrapped token. Name your new account and click Create . Wrap and Delegate # Users can wrap and delegate their $SGB / $WSGB using D'cent's native FTSO Portal: Delegation instructions for the Flare network are awaiting confirmation Click the Discovery tab at the bottom middle of the screen. Select the FTSO Portal from the menu then click Go . Choose the Songbird account you wish to use and click Connect . You will need to wrap your $SGB by clicking SGB \u2194\ufe0f WSGB marked in green near the top middle of the screen. Input the $SGB amount you want to wrap and click the green SGB \u2194\ufe0f WSGB box. Click Confirm and follow the prompts to sign the transaction with your hardware device. You can now delegate your $WSGB by clicking Add delegation . Select a provider and input the percentage of your $WSGB holdings you want to delegate to their service and press Delegate . Note Providers listed as a Partner have additional security features integrated with D'cent. Click Confirm and follow the prompts to sign the transaction with your hardware device. Repeat steps 7 through 9 if you wish to add a second provider (up to two).","title":"D'CENT Wallet"},{"location":"user/wallets/dcent-wallet/#dcent-wallet","text":"D'CENT Biometric Wallet is a non-custodial hardware wallet and is considered one of the most secure ways to manage your crypto assets.","title":"D'CENT Wallet"},{"location":"user/wallets/dcent-wallet/#getting-started","text":"Purchase a D'CENT Biometric hardware wallet from the official D'CENT shop or download their software wallet/mobile app from the Apple App Store or Google Play Store . Then either initialize a new wallet or import an existing one from a recovery phrase. The official D'cent device setup help guides can be found here: https://userguide.dcentwallet.com/biometric-wallet/setting-up . Once your device is set up and synced with the mobile app you will need to add $FLR and $SGB to your listed assets: Ensure the D'cent biometric wallet is updated with the latest firmware, v2.24.0 or later. Login to your D'cent mobile app and have your device turned on, unlocked, and paired via Bluetooth. Click the + sign on the bottom right of the Account tab. Search for \"Flare\" or \"Songbird\" in the search box. Select the Flare Token (FLR) or Songbird Token (SGB) . Name your new account and click Create . Repeat for the other token. You should also add the wrapped versions of the tokens ( $WFLR and $WSGB ) to the listed assets: With your device unlocked and paired, click the + sign on the bottom right of the Account tab. Search for \"Wrapped Flare\" or \"Wrapped Songbird\" in the search box. Select the wrapped token. Name your new account and click Create .","title":"Getting Started"},{"location":"user/wallets/dcent-wallet/#wrap-and-delegate","text":"Users can wrap and delegate their $SGB / $WSGB using D'cent's native FTSO Portal: Delegation instructions for the Flare network are awaiting confirmation Click the Discovery tab at the bottom middle of the screen. Select the FTSO Portal from the menu then click Go . Choose the Songbird account you wish to use and click Connect . You will need to wrap your $SGB by clicking SGB \u2194\ufe0f WSGB marked in green near the top middle of the screen. Input the $SGB amount you want to wrap and click the green SGB \u2194\ufe0f WSGB box. Click Confirm and follow the prompts to sign the transaction with your hardware device. You can now delegate your $WSGB by clicking Add delegation . Select a provider and input the percentage of your $WSGB holdings you want to delegate to their service and press Delegate . Note Providers listed as a Partner have additional security features integrated with D'cent. Click Confirm and follow the prompts to sign the transaction with your hardware device. Repeat steps 7 through 9 if you wish to add a second provider (up to two).","title":"Wrap and Delegate"},{"location":"user/wallets/how-to-access-flare-network-with-a-ledger-device/","text":"Ledger Nano X and Nano S # Hardware wallets are considered among the more secure options to manage crypto assets and store private keys. Your crypto assets can remain safe, even if your computer or phone is compromised, as long as you keep your recovery phrase safe and review all transaction details before confirming transactions. Flare support instructions awaiting confirmation Getting Started # To use your Ledger device with Songbird ( $SGB ), first make sure that you have: Initialized your Ledger device with a recovery phrase. Protected your Ledger device with a PIN code. Ledger Live is installed, open and ready to use. Installed the latest Ledger device firmware. Installed the latest version of the Ledger Ethereum app. Installed the latest version of Google Chrome . Installed the MetaMask browser extension version 10.5.0 or later . Install the Songbird App # After meeting the requirements, you can install the Songbird app by following these steps: Open the Manager in Ledger Live. Connect and unlock your Ledger device. Allow the manager on your Ledger device by pressing both buttons. Find Songbird in the app catalog. Click the Install button of the app. Your Ledger device will display Processing\u2026 . The app installation is complete. Info Both Ethereum and Songbird Ledger apps can be used to sign transactions for the Songbird network. Use Ledger Device with MetaMask # You can access Songbird by using your Ledger device with the MetaMask browser extension. Open the MetaMask browser extension and login. Click on Custom RPC in the networks dropdown a) Enter network name: Songbird . b) Enter RPC URL: https://songbird.towolabs.com/rpc . c) Enter chain ID: 19 . d) Enter symbol: SGB . e) Enter block explorer URL: https://songbird-explorer.flare.network . f) Click Save. Select Songbird in the network dropdown. Connect your Ledger device using USB. Open the Songbird app on your Ledger device. If Ledger Live is still running, you must now quit the app on your computer. In MetaMask's Advanced Settings ensure that the Preferred Ledger Connection Type is set to WebHID in the drop-down menu (it should be the case by default). Click your account image and Connect Hardware Wallet . A pop up box will appear listing paired Human Interface Devices (HID). Highlight your Ledger S or Ledger X and click Connect . Select your Account and click Unlock . Info Please note that Towo Labs RPC node available at https://songbird.towolabs.com/rpc is only for individuals and not for commercial use . Companies and developers may contact Towo Labs to arrange dedicated access. You will see your $SGB balance on the overview. To receive $SGB , copy your account address and share it with the sender. To send $SGB , click Send and enter the recipient address, enter the desired amount and click Next . If prompted, allow MetaMask to open Ledger Live and open the device bridge. Follow the on screen instructions to confirm or reject the transaction on your Ledger device. Warning Always review all transaction details on your Ledger device before confirming any transaction! Wrap and Delegate # Once connected to the Songbird network, enter the address of the website or dapp you wish to use to wrap and delegate in the MetaMask browser. A few of the data providers have developed dapps integrated with their websites that allow users to wrap, delegate and claim $SGB rewards. Delegating using this method is not exclusive to one specific provider, as these dapps allow you to choose from a number of different providers. Many data providers have developed dapps for wrapping and delegation. Take a look at flaremetrics.io and pick the one you prefer. Other providers have their own websites and are developing similar dapps. See the full list of active signal providers on flaremetrics.io/ftso .","title":"Ledger Nano X and Nano S"},{"location":"user/wallets/how-to-access-flare-network-with-a-ledger-device/#ledger-nano-x-and-nano-s","text":"Hardware wallets are considered among the more secure options to manage crypto assets and store private keys. Your crypto assets can remain safe, even if your computer or phone is compromised, as long as you keep your recovery phrase safe and review all transaction details before confirming transactions. Flare support instructions awaiting confirmation","title":"Ledger Nano X and Nano S"},{"location":"user/wallets/how-to-access-flare-network-with-a-ledger-device/#getting-started","text":"To use your Ledger device with Songbird ( $SGB ), first make sure that you have: Initialized your Ledger device with a recovery phrase. Protected your Ledger device with a PIN code. Ledger Live is installed, open and ready to use. Installed the latest Ledger device firmware. Installed the latest version of the Ledger Ethereum app. Installed the latest version of Google Chrome . Installed the MetaMask browser extension version 10.5.0 or later .","title":"Getting Started"},{"location":"user/wallets/how-to-access-flare-network-with-a-ledger-device/#install-the-songbird-app","text":"After meeting the requirements, you can install the Songbird app by following these steps: Open the Manager in Ledger Live. Connect and unlock your Ledger device. Allow the manager on your Ledger device by pressing both buttons. Find Songbird in the app catalog. Click the Install button of the app. Your Ledger device will display Processing\u2026 . The app installation is complete. Info Both Ethereum and Songbird Ledger apps can be used to sign transactions for the Songbird network.","title":"Install the Songbird App"},{"location":"user/wallets/how-to-access-flare-network-with-a-ledger-device/#use-ledger-device-with-metamask","text":"You can access Songbird by using your Ledger device with the MetaMask browser extension. Open the MetaMask browser extension and login. Click on Custom RPC in the networks dropdown a) Enter network name: Songbird . b) Enter RPC URL: https://songbird.towolabs.com/rpc . c) Enter chain ID: 19 . d) Enter symbol: SGB . e) Enter block explorer URL: https://songbird-explorer.flare.network . f) Click Save. Select Songbird in the network dropdown. Connect your Ledger device using USB. Open the Songbird app on your Ledger device. If Ledger Live is still running, you must now quit the app on your computer. In MetaMask's Advanced Settings ensure that the Preferred Ledger Connection Type is set to WebHID in the drop-down menu (it should be the case by default). Click your account image and Connect Hardware Wallet . A pop up box will appear listing paired Human Interface Devices (HID). Highlight your Ledger S or Ledger X and click Connect . Select your Account and click Unlock . Info Please note that Towo Labs RPC node available at https://songbird.towolabs.com/rpc is only for individuals and not for commercial use . Companies and developers may contact Towo Labs to arrange dedicated access. You will see your $SGB balance on the overview. To receive $SGB , copy your account address and share it with the sender. To send $SGB , click Send and enter the recipient address, enter the desired amount and click Next . If prompted, allow MetaMask to open Ledger Live and open the device bridge. Follow the on screen instructions to confirm or reject the transaction on your Ledger device. Warning Always review all transaction details on your Ledger device before confirming any transaction!","title":"Use Ledger Device with MetaMask"},{"location":"user/wallets/how-to-access-flare-network-with-a-ledger-device/#wrap-and-delegate","text":"Once connected to the Songbird network, enter the address of the website or dapp you wish to use to wrap and delegate in the MetaMask browser. A few of the data providers have developed dapps integrated with their websites that allow users to wrap, delegate and claim $SGB rewards. Delegating using this method is not exclusive to one specific provider, as these dapps allow you to choose from a number of different providers. Many data providers have developed dapps for wrapping and delegation. Take a look at flaremetrics.io and pick the one you prefer. Other providers have their own websites and are developing similar dapps. See the full list of active signal providers on flaremetrics.io/ftso .","title":"Wrap and Delegate"},{"location":"user/wallets/how-to-access-flare-network-with-a-trezor-device/","text":"Trezor T # Hardware wallets are considered among the more secure options to manage crypto assets and store private keys. Your crypto assets can remain safe, even if your computer or phone is compromised, as long as you keep your recovery phrase safe and review all transaction details before confirming transactions. Getting Started # To use your Trezor device with Flare ( $FLR ) or Songbird ( $SGB ), first make sure that you have: Initialized your Trezor device with a recovery phrase. Protected your Trezor device with a PIN code. Trezor Suite is installed, open and ready to use. Enabled Ethereum under the Crypto tab in Trezor Suite. Installed the latest Trezor device firmware. Installed the latest version of Google Chrome . Installed the MetaMask browser extension . Use Trezor T Device with MetaMask # You can access Flare and Songbird by using your Trezor T with the MetaMask browser extension. Open the MetaMask browser extension in your browser. Click on Custom RPC in the network dropdown. Songbird Flare Field Value Network Name Songbird New RPC URL https://songbird-api.flare.network/ext/C/rpc Chain ID 19 Currency Symbol SGB Block Explorer URL https://songbird-explorer.flare.network Field Value Network Name Flare New RPC URL https://flare-api.flare.network/ext/C/rpc Chain ID 14 Currency Symbol FLR Block Explorer URL https://flare-explorer.flare.network Finally, click Save . Select Flare or Songbird in the network dropdown. Connect and unlock your Trezor device. Click your account image and Connect Hardware Wallet . Select Trezor and click Continue . Follow the on screen instructions to export your public key. Select your Account and click Unlock . Info Please note that the provided Flare RPC node is only for individuals and not for commercial use . Companies and developers may contact Flare Networks to arrange dedicated access. You will see your $FLR or $SGB balance on the overview. To receive tokens, copy your account address and share it with the sender. To send tokens, click Send and enter the recipient address, enter the desired amount and click Next . Follow the on screen instructions to confirm or reject the transaction on your Trezor device. Warning Always review all transaction details on your Trezor device before confirming any transaction! Wrap and Delegate # Once connected to a Flare network, enter the address of the website or dapp you wish to use to wrap and delegate in the MetaMask browser. A few FTSO data providers have developed dApps integrated with their websites that allow users to wrap, delegate and claim SGB and Flare rewards. Delegating using this method is not exclusive to one specific provider, as these dapps allow you to choose from a number of different providers. Other providers have their own websites and are developing similar dapps. See the full list of active data providers on flaremetrics.io/ftso .","title":"Trezor T"},{"location":"user/wallets/how-to-access-flare-network-with-a-trezor-device/#trezor-t","text":"Hardware wallets are considered among the more secure options to manage crypto assets and store private keys. Your crypto assets can remain safe, even if your computer or phone is compromised, as long as you keep your recovery phrase safe and review all transaction details before confirming transactions.","title":"Trezor T"},{"location":"user/wallets/how-to-access-flare-network-with-a-trezor-device/#getting-started","text":"To use your Trezor device with Flare ( $FLR ) or Songbird ( $SGB ), first make sure that you have: Initialized your Trezor device with a recovery phrase. Protected your Trezor device with a PIN code. Trezor Suite is installed, open and ready to use. Enabled Ethereum under the Crypto tab in Trezor Suite. Installed the latest Trezor device firmware. Installed the latest version of Google Chrome . Installed the MetaMask browser extension .","title":"Getting Started"},{"location":"user/wallets/how-to-access-flare-network-with-a-trezor-device/#use-trezor-t-device-with-metamask","text":"You can access Flare and Songbird by using your Trezor T with the MetaMask browser extension. Open the MetaMask browser extension in your browser. Click on Custom RPC in the network dropdown. Songbird Flare Field Value Network Name Songbird New RPC URL https://songbird-api.flare.network/ext/C/rpc Chain ID 19 Currency Symbol SGB Block Explorer URL https://songbird-explorer.flare.network Field Value Network Name Flare New RPC URL https://flare-api.flare.network/ext/C/rpc Chain ID 14 Currency Symbol FLR Block Explorer URL https://flare-explorer.flare.network Finally, click Save . Select Flare or Songbird in the network dropdown. Connect and unlock your Trezor device. Click your account image and Connect Hardware Wallet . Select Trezor and click Continue . Follow the on screen instructions to export your public key. Select your Account and click Unlock . Info Please note that the provided Flare RPC node is only for individuals and not for commercial use . Companies and developers may contact Flare Networks to arrange dedicated access. You will see your $FLR or $SGB balance on the overview. To receive tokens, copy your account address and share it with the sender. To send tokens, click Send and enter the recipient address, enter the desired amount and click Next . Follow the on screen instructions to confirm or reject the transaction on your Trezor device. Warning Always review all transaction details on your Trezor device before confirming any transaction!","title":"Use Trezor T Device with MetaMask"},{"location":"user/wallets/how-to-access-flare-network-with-a-trezor-device/#wrap-and-delegate","text":"Once connected to a Flare network, enter the address of the website or dapp you wish to use to wrap and delegate in the MetaMask browser. A few FTSO data providers have developed dApps integrated with their websites that allow users to wrap, delegate and claim SGB and Flare rewards. Delegating using this method is not exclusive to one specific provider, as these dapps allow you to choose from a number of different providers. Other providers have their own websites and are developing similar dapps. See the full list of active data providers on flaremetrics.io/ftso .","title":"Wrap and Delegate"},{"location":"user/wallets/how-to-access-flare-network-with-metamask/","text":"MetaMask # The MetaMask browser extension is a convenient way to access and interact with blockchains like Songbird or Flare. To do so, you need to first add a custom network to MetaMask, as explained in this guide. Make sure that you have securely backed up your recovery phrase before proceeding. Getting Started # To use MetaMask with Songbird or Flare, first make sure that you have: Installed the latest version of Google Chrome . Installed the MetaMask browser extension . Created a new wallet or imported an existing wallet to MetaMask. Securely backed up your recovery phrase offline. Protected your MetaMask with a password. Once your wallet is set up, you need to add a custom network to the MetaMask browser extension: Open the MetaMask browser extension. Unlock your MetaMask wallet with your password. Click on Custom RPC in the network dropdown menu. Songbird Flare Field Value Network Name Songbird New RPC URL https://songbird-api.flare.network/ext/C/rpc Chain ID 19 Currency Symbol SGB Block Explorer URL https://songbird-explorer.flare.network Field Value Network Name Flare New RPC URL https://flare-api.flare.network/ext/C/rpc Chain ID 14 Currency Symbol FLR Block Explorer URL https://flare-explorer.flare.network Finally, click Save . Select Songbird or Flare in the network dropdown menu You should now be able to see your Songbird or Flare balance on the overview. To receive tokens, copy your account address and share it with the sender. To send tokens, click Send and enter the recipient address, enter the desired amount and click Next . Warning Always review all transaction details in MetaMask before confirming any transaction! Wrap and Delegate # Once connected to a Flare network, enter the address of the website or dApp you wish to use to wrap and delegate in MetaMask. A few FTSO data providers have developed dApps integrated with their websites that allow users to wrap, delegate and claim SGB and Flare rewards. Delegating using this method is not exclusive to one specific provider, as these dApps allow you to choose from a number of different providers. Other providers have their own websites and are developing similar dapps. See the full list of active data providers on flaremetrics.io/ftso .","title":"MetaMask"},{"location":"user/wallets/how-to-access-flare-network-with-metamask/#metamask","text":"The MetaMask browser extension is a convenient way to access and interact with blockchains like Songbird or Flare. To do so, you need to first add a custom network to MetaMask, as explained in this guide. Make sure that you have securely backed up your recovery phrase before proceeding.","title":"MetaMask"},{"location":"user/wallets/how-to-access-flare-network-with-metamask/#getting-started","text":"To use MetaMask with Songbird or Flare, first make sure that you have: Installed the latest version of Google Chrome . Installed the MetaMask browser extension . Created a new wallet or imported an existing wallet to MetaMask. Securely backed up your recovery phrase offline. Protected your MetaMask with a password. Once your wallet is set up, you need to add a custom network to the MetaMask browser extension: Open the MetaMask browser extension. Unlock your MetaMask wallet with your password. Click on Custom RPC in the network dropdown menu. Songbird Flare Field Value Network Name Songbird New RPC URL https://songbird-api.flare.network/ext/C/rpc Chain ID 19 Currency Symbol SGB Block Explorer URL https://songbird-explorer.flare.network Field Value Network Name Flare New RPC URL https://flare-api.flare.network/ext/C/rpc Chain ID 14 Currency Symbol FLR Block Explorer URL https://flare-explorer.flare.network Finally, click Save . Select Songbird or Flare in the network dropdown menu You should now be able to see your Songbird or Flare balance on the overview. To receive tokens, copy your account address and share it with the sender. To send tokens, click Send and enter the recipient address, enter the desired amount and click Next . Warning Always review all transaction details in MetaMask before confirming any transaction!","title":"Getting Started"},{"location":"user/wallets/how-to-access-flare-network-with-metamask/#wrap-and-delegate","text":"Once connected to a Flare network, enter the address of the website or dApp you wish to use to wrap and delegate in MetaMask. A few FTSO data providers have developed dApps integrated with their websites that allow users to wrap, delegate and claim SGB and Flare rewards. Delegating using this method is not exclusive to one specific provider, as these dApps allow you to choose from a number of different providers. Other providers have their own websites and are developing similar dapps. See the full list of active data providers on flaremetrics.io/ftso .","title":"Wrap and Delegate"},{"location":"user/wallets/safepal-s1-wallet/","text":"SafePal S1 Wallet # SafePal S1 is a non-custodial hardware wallet that is considered one of the most secure ways to manage your crypto assets. Getting Started # Purchase a SafePal S1 hardware device from the official SafePal website in the products section and download their mobile app from either the Apple App Store or Google Play Store . Use of a SafePal S1 hardware wallet requires syncing the device with the mobile app. A step by step unboxing guide to initialize a new device/wallet, or import an existing one from a recovery phrase, can be found here: https://safepalsupport.zendesk.com/hc/en-us/articles/360046051752-How-to-Set-Up-a-S1-Hardware-Wallet . Once your S1 device is set up and synced with the mobile app you will need to add $SGB and $FLR to your listed assets: Ensure the SafePal S1 is updated with the latest firmware, version V1.0.32 or later. Login to your SafePal mobile app and have your S1 device turned on and unlocked. Scroll to the bottom of your listed assets in the mobile app and select Add . Search for Songbird ( $SGB ) or Flare ( $FLR ) and click the gray button on the right which will then turn blue. Click the Add Coin box also in blue at the bottom of the screen. Follow the series of prompts which require scanning QR codes from both your S1 wallet and mobile app to finalize adding the asset. Wrap and Delegate # SafePal users can access existing decentralized applications (dApps) created by independent FTSO data providers to wrap and delegate their $SGB and $FLR tokens: Open the SafePal mobile app and navigate to the built-in web browser by clicking the four squares at the bottom middle of the screen. Enter the address of the website or dApp you wish to use to wrap and delegate in the search bar at the top of the screen. Info These dApps are usually created by FTSO data providers , but some of them allow you to choose a different data provider to delegate to. Take a look at flaremetrics.io and pick the one you prefer. After copying and pasting the address, click the drop-down menu to the right of the search tab. Scroll down, select the Songbird or Flare networks, and click Go . A pop up will appear notifying that you are being redirected to a third party dApp. Press Confirm . Other data providers host similar websites or dApps for wrapping and delegation. See the full list of signal providers on Songbird at https://flaremetrics.io/ftso .","title":"SafePal S1 Wallet"},{"location":"user/wallets/safepal-s1-wallet/#safepal-s1-wallet","text":"SafePal S1 is a non-custodial hardware wallet that is considered one of the most secure ways to manage your crypto assets.","title":"SafePal S1 Wallet"},{"location":"user/wallets/safepal-s1-wallet/#getting-started","text":"Purchase a SafePal S1 hardware device from the official SafePal website in the products section and download their mobile app from either the Apple App Store or Google Play Store . Use of a SafePal S1 hardware wallet requires syncing the device with the mobile app. A step by step unboxing guide to initialize a new device/wallet, or import an existing one from a recovery phrase, can be found here: https://safepalsupport.zendesk.com/hc/en-us/articles/360046051752-How-to-Set-Up-a-S1-Hardware-Wallet . Once your S1 device is set up and synced with the mobile app you will need to add $SGB and $FLR to your listed assets: Ensure the SafePal S1 is updated with the latest firmware, version V1.0.32 or later. Login to your SafePal mobile app and have your S1 device turned on and unlocked. Scroll to the bottom of your listed assets in the mobile app and select Add . Search for Songbird ( $SGB ) or Flare ( $FLR ) and click the gray button on the right which will then turn blue. Click the Add Coin box also in blue at the bottom of the screen. Follow the series of prompts which require scanning QR codes from both your S1 wallet and mobile app to finalize adding the asset.","title":"Getting Started"},{"location":"user/wallets/safepal-s1-wallet/#wrap-and-delegate","text":"SafePal users can access existing decentralized applications (dApps) created by independent FTSO data providers to wrap and delegate their $SGB and $FLR tokens: Open the SafePal mobile app and navigate to the built-in web browser by clicking the four squares at the bottom middle of the screen. Enter the address of the website or dApp you wish to use to wrap and delegate in the search bar at the top of the screen. Info These dApps are usually created by FTSO data providers , but some of them allow you to choose a different data provider to delegate to. Take a look at flaremetrics.io and pick the one you prefer. After copying and pasting the address, click the drop-down menu to the right of the search tab. Scroll down, select the Songbird or Flare networks, and click Go . A pop up will appear notifying that you are being redirected to a third party dApp. Press Confirm . Other data providers host similar websites or dApps for wrapping and delegation. See the full list of signal providers on Songbird at https://flaremetrics.io/ftso .","title":"Wrap and Delegate"}]}